---
title: "树莓派服务部署与维护完整指南"
date: 2024-12-03T18:00:00+08:00
draft: false
categories: ["技术"]
tags: ["RaspberryPi", "Hugo", "教程"]
cover: "/images/default3.jpg"
---

# 树莓派服务部署与维护完整指南

## 一、系统概况
### 1. 硬件资源
- **处理器**: ARM64 架构
- **总内存**: 3.7GB
- **可用内存**: ~2.5GB
- **Swap**: 512MB
- **网络**: wlan0 (IP: 10.40.110.47)
### 2. 服务概览
1. **AI 智能助手**
   - 端口: 8080
   - 基于: llama.cpp
   - 模型: Phi-3-mini-4k-instruct-q4.gguf
   - 资源占用:
     * CPU: ~300% (多核)
     * 内存: ~3GB
     * Swap: 511Mi
2. **个人博客**
   - 端口: 80
   - 框架: Hugo v0.139.3-extended
   - 主题: Ananke
   - Web服务器: Nginx
   - 资源占用: 轻量级
### 3. 服务访问
- AI 助手: `http://10.40.110.47:8080`
- 博客开发: `http://10.40.110.47:1313`
- 博客正式: `http://10.40.110.47`
## 二、AI 智能助手部署
### 1. 环境准备
```bash
# 更新系统
sudo apt update
sudo apt upgrade -y

# 安装依赖
sudo apt install build-essential git cmake
```

### 2. 编译安装
```bash
# 克隆仓库
git clone https://github.com/ggerganov/llama.cpp.git
cd llama.cpp

# 编译
make clean
LLAMA_METAL=1 make -j4
```

### 3. 模型配置
```bash
# 创建模型目录
mkdir models
cd models

# 下载模型文件
wget [模型下载地址]/Phi-3-mini-4k-instruct-q4.gguf

# 验证模型文件
sha256sum Phi-3-mini-4k-instruct-q4.gguf
```

### 4. 服务配置
```bash
# 创建启动脚本
nano ~/projects/llama.cpp/start-llama.sh
```

```bash
#!/bin/bash
cd ~/projects/llama.cpp
nohup ./llama-server \
  -m models/Phi-3-mini-4k-instruct-q4.gguf \
  --host 0.0.0.0 \
  --port 8080 \
  --ctx-size 2048 \
  --threads 2 \
  --batch-size 256 \
  > llama.log 2>&1 &
```

```bash
# 设置执行权限
chmod +x start-llama.sh

# 启动服务
./start-llama.sh

# 验证服务状态
ps aux | grep llama-server
netstat -tuln | grep 8080
```

## 三、个人博客部署
### 1. Hugo 安装
```bash
# 下载 Hugo Extended 版本
wget https://github.com/gohugoio/hugo/releases/download/v0.139.3/hugo_extended_0.139.3_linux-arm64.deb

# 安装
sudo dpkg -i hugo_extended_0.139.3_linux-arm64.deb

# 验证安装
hugo version
```

### 2. 博客初始化
```bash
# 创建站点
cd ~
hugo new site myblog
cd myblog

# 初始化 Git
git init

# 添加主题
git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke
```

### 3. 博客配置
```bash
# 编辑配置文件
nano config.toml
```
```toml
baseURL = "http://10.40.110.47/"
languageCode = "zh-cn"
title = "My Blog"
theme = "ananke"

[params]
  author = "Your Name"
  description = "Welcome to my blog"
  dateFormat = "2006-01-02"
  background_color_class = "bg-black"
  recent_posts_number = 3
  mainSections = ["posts"]
  featured_image = false

[menu]
  [[menu.main]]
    identifier = "posts"
    name = "文章"
    url = "/posts/"
    weight = 1
  [[menu.main]]
    identifier = "about"
    name = "关于"
    url = "/about/"
    weight = 2
```

### 4. Nginx 配置
```bash
# 安装 Nginx
sudo apt install nginx

# 创建配置文件
sudo nano /etc/nginx/sites-available/myblog
```

```nginx
server {
    listen 80;
    server_name 10.40.110.47;

    root /home/zhaoxiongzhou/myblog/public;
    index index.html;

    location / {
        try_files $uri $uri/ =404;
    }

    access_log /var/log/nginx/myblog_access.log;
    error_log /var/log/nginx/myblog_error.log;
}
```


```bash
# 启用配置
sudo ln -s /etc/nginx/sites-available/myblog /etc/nginx/sites-enabled/
sudo rm /etc/nginx/sites-enabled/default

# 测试配置
sudo nginx -t

# 重启 Nginx
sudo systemctl restart nginx
```

## 四、权限与自动化配置
### 1. 权限设置
```bash
# 设置目录权限
sudo chmod 755 /home/zhaoxiongzhou
sudo chmod -R 755 /home/zhaoxiongzhou/myblog

# 设置文件所有权
sudo chown -R www-data:www-data /home/zhaoxiongzhou/myblog/public

# 验证权限
ls -la ~/myblog/public
ls -la /home/zhaoxiongzhou
```

### 2. 自动部署脚本
```bash
# 创建博客部署脚本
nano ~/deploy-blog.sh
```
```bash
#!/bin/bash
cd ~/myblog
hugo
sudo chown -R www-data:www-data public/
sudo systemctl restart nginx
```
```bash
# 设置执行权限
chmod +x ~/deploy-blog.sh
```

### 3. 备份脚本
```bash
# 创建备份脚本
nano ~/backup-blog.sh
```
```bash
#!/bin/bash
BACKUP_DIR="/home/zhaoxiongzhou/backups"
DATE=$(date +%Y%m%d)

# 创建备份目录
mkdir -p $BACKUP_DIR

# 备份博客内容
tar -czf $BACKUP_DIR/blog_$DATE.tar.gz ~/myblog/content

# 备份配置文件
cp ~/myblog/config.toml $BACKUP_DIR/config_$DATE.toml

# 删除30天前的备份
find $BACKUP_DIR -name "*.tar.gz" -mtime +30 -delete
```

```bash
# 设置执行权限
chmod +x ~/backup-blog.sh

# 配置定时任务
crontab -e
```

```bash
# 添加定时任务（每周日凌晨2点执行备份）
0 2 * * 0 /home/zhaoxiongzhou/backup-blog.sh
```
## 五、系统维护与监控
### 1. 资源监控命令
```bash
# 系统资源监控
htop
top
free -h
vmstat 1

# 磁盘使用监控
df -h
du -sh /*
du -sh ~/myblog
du -sh ~/projects/llama.cpp

# 温度监控
vcgencmd measure_temp
```
### 2. 性能优化
```bash
# 清理系统缓存
sudo sync; echo 3 | sudo tee /proc/sys/vm/drop_caches

# 调整 Swap 设置
cat /proc/sys/vm/swappiness
sudo sysctl vm.swappiness=60

# CPU 频率调整
sudo nano /boot/config.txt
```

```toml
# CPU 配置参数
arm_freq=1800
over_voltage=6
temp_limit=75
```

### 3. 系统维护
```bash
# 系统更新
sudo apt update
sudo apt upgrade -y
sudo apt autoremove
sudo apt clean

# 日志清理
sudo find /var/log -type f -name "*.log" -mtime +30 -delete
sudo find /var/log -type f -name "*.gz" -delete

# 服务状态检查
systemctl status nginx
ps aux | grep llama-server
```

## 六、安全配置
### 1. 防火墙设置
```bash
# 安装 UFW
sudo apt install ufw

# 配置基本规则
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow 22
sudo ufw allow 80
sudo ufw allow 8080

# 启用防火墙
sudo ufw enable

# 检查状态
sudo ufw status
```
### 2. Nginx 访问控制
```bash
# 安装认证工具
sudo apt install apache2-utils

# 创建用户密码
sudo htpasswd -c /etc/nginx/.htpasswd username

# 修改 Nginx 配置
sudo nano /etc/nginx/sites-available/myblog
```

```nginx
server {
    listen 80;
    server_name 10.40.110.47;

    root /home/zhaoxiongzhou/myblog/public;
    index index.html;

    # 添加基本认证
    location / {
        auth_basic "Restricted Access";
        auth_basic_user_file /etc/nginx/.htpasswd;
        try_files $uri $uri/ =404;
    }

    # 日志配置
    access_log /var/log/nginx/myblog_access.log;
    error_log /var/log/nginx/myblog_error.log;
}
```
### 3. 日志监控
```bash
# 安装日志监控工具
sudo apt install logwatch

# 配置日志监控
sudo nano /etc/logwatch/conf/logwatch.conf
```

```toml
# 配置每日日志检查
Output = mail
Format = html
MailTo = your-email@domain.com
Detail = High
```

## 七、故障排除指南
#### 内存相关问题
```bash
# 检查内存状态
free -h
ps aux --sort=-%mem | head

# 如果内存不足，调整服务参数
nano ~/projects/llama.cpp/start-llama.sh
```
```bash
# 降低资源使用的参数示例
--ctx-size 1024 \
--batch-size 128 \
--threads 1
```
#### 服务无响应
```bash
# 检查进程
ps aux | grep llama-server

# 检查端口
netstat -tuln | grep 8080

# 重启服务
pkill llama-server
./start-llama.sh

# 检查日志
tail -f ~/projects/llama.cpp/llama.log
```
### 2. 博客服务故障排除
#### Nginx 问题
```bash
# 检查配置语法
sudo nginx -t

# 检查日志
sudo tail -f /var/log/nginx/error.log
sudo tail -f /var/log/nginx/myblog_error.log

# 检查服务状态
sudo systemctl status nginx

# 重启服务
sudo systemctl restart nginx
```

#### Hugo 生成问题
```bash
# 清理缓存
rm -rf ~/myblog/public
rm -rf ~/myblog/resources

# 更新主题
git submodule update --init --recursive

# 重新生成（详细模式）
hugo --verbose
```

## 八、系统级故障排除
### 1. 磁盘问题
```bash
# 检查磁盘使用情况
df -h
du -sh /*

# 查找大文件
sudo find / -type f -size +100M

# 清理空间
sudo apt clean
sudo apt autoremove
sudo journalctl --vacuum-time=7d
```

### 2. 网络问题
```bash
# 网络状态检查
ip addr show
ping -c 4 8.8.8.8
netstat -tuln

# DNS 检查
cat /etc/resolv.conf
nslookup google.com

# 重启网络服务
sudo systemctl restart networking
sudo systemctl restart wpa_supplicant
```

### 3. 性能问题
```bash
# CPU 温度监控
vcgencmd measure_temp
watch -n 1 vcgencmd measure_temp

# CPU 频率检查
vcgencmd measure_clock arm
cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_cur_freq

# 系统负载检查
uptime
cat /proc/loadavg
```

## 九、维护最佳实践
### 1. 日常维护清单
- 检查系统日志
- 监控资源使用
- 验证服务状态
- 检查备份状态
- 更新系统安全补丁
### 2. 周期性维护任务
- 清理旧日志和临时文件
- 验证备份完整性
- 检查系统更新
- 检查服务性能
- 更新文档和配置说明
### 3. 应急预案
- 保存所有配置文件的备份
- 记录所有服务的配置步骤
- 维护问题解决方案文档
- 建立服务恢复流程
- 保持重要数据的多份备份

## 十、性能优化建议
### 1. 系统级优化
```bash
# 1. 调整 SWAP 设置
sudo nano /etc/sysctl.conf
```
```toml
# 添加或修改以下参数
vm.swappiness=60
vm.vfs_cache_pressure=50
vm.dirty_background_ratio=5
vm.dirty_ratio=10
```
```bash
# 2. 优化文件系统
# 检查并优化文件系统
sudo tune2fs -o journal_data_writeback /dev/mmcblk0p2

# 3. 调整 CPU 性能
sudo nano /boot/config.txt
```
```toml
# 添加以下配置
arm_freq=1800
over_voltage=6
gpu_freq=500
dtparam=audio=on
```
### 2. 服务优化
#### AI 服务优化
```bash
# 调整服务参数
nano ~/projects/llama.cpp/start-llama.sh
```
```toml
# 优化参数示例
--ctx-size 2048 \
--threads 2 \
--batch-size 256 \
--keep-context \
--mlock \
--numa
```

#### Nginx 优化
```bash
sudo nano /etc/nginx/nginx.conf
```
```toml
worker_processes auto;
worker_rlimit_nofile 65535;

events {
    worker_connections 1024;
    multi_accept on;
    use epoll;
}

http {
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_tokens off;

    # 缓存设置
    open_file_cache max=1000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;
}
```
## 十一、监控与报警系统
### 1. 系统监控配置
```bash
# 安装监控工具
sudo apt install prometheus node-exporter grafana

# 配置 Prometheus
sudo nano /etc/prometheus/prometheus.yml
```
```toml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'node'
    static_configs:
      - targets: ['localhost:9100']

  - job_name: 'nginx'
    static_configs:
      - targets: ['localhost:9113']
```

### 2. 自动报警脚本
```bash
# 创建监控脚本
nano ~/monitor.sh
```
```bash
#!/bin/bash

# 定义阈值
MAX_CPU_USAGE=90
MAX_MEM_USAGE=90
MAX_DISK_USAGE=90
MAX_TEMP=75

# 获取系统数据
CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}' | cut -d. -f1)
MEM_USAGE=$(free | grep Mem | awk '{print $3/$2 * 100.0}')
DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | cut -d% -f1)
TEMP=$(vcgencmd measure_temp | cut -d= -f2 | cut -d. -f1)

# 检查服务状态
check_services() {
    services=("nginx" "llama-server")
    for service in "${services[@]}"; do
        if ! pgrep -x "$service" > /dev/null; then
            echo "警告: $service 服务未运行!"
            # 可以添加重启服务的命令
        fi
    done
}

# 发送警告
send_alert() {
    message="$1"
    # 这里可以添加发送邮件或其他通知的命令
    echo "$message" >> /var/log/system_alerts.log
}

# 检查各项指标
if [ "$CPU_USAGE" -gt "$MAX_CPU_USAGE" ]; then
    send_alert "CPU 使用率过高: $CPU_USAGE%"
fi

if [ "${MEM_USAGE%.*}" -gt "$MAX_MEM_USAGE" ]; then
    send_alert "内存使用率过高: $MEM_USAGE%"
fi

if [ "$DISK_USAGE" -gt "$MAX_DISK_USAGE" ]; then
    send_alert "磁盘使用率过高: $DISK_USAGE%"
fi

if [ "$TEMP" -gt "$MAX_TEMP" ]; then
    send_alert "系统温度过高: $TEMP°C"
fi

# 检查服务状态
check_services
```
```bash
# 设置执行权限
chmod +x ~/monitor.sh

# 添加到 crontab
crontab -e
```
```bash
# 每5分钟执行一次监控
*/5 * * * * /home/zhaoxiongzhou/monitor.sh
```
## 十二、数据备份与恢复
### 1. 完整备份方案
```bash
# 创建完整备份脚本
nano ~/full-backup.sh
```
```bash
#!/bin/bash
BACKUP_ROOT="/home/zhaoxiongzhou/backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="$BACKUP_ROOT/$DATE"

# 创建备份目录
mkdir -p "$BACKUP_DIR"

# 备份博客内容
echo "备份博客内容..."
tar -czf "$BACKUP_DIR/blog_content.tar.gz" ~/myblog/content
tar -czf "$BACKUP_DIR/blog_config.tar.gz" ~/myblog/config.toml

# 备份 AI 模型和配置
echo "备份 AI 服务..."
tar -czf "$BACKUP_DIR/llama_models.tar.gz" ~/projects/llama.cpp/models
tar -czf "$BACKUP_DIR/llama_config.tar.gz" ~/projects/llama.cpp/start-llama.sh

# 备份 Nginx 配置
echo "备份 Nginx 配置..."
sudo tar -czf "$BACKUP_DIR/nginx_config.tar.gz" /etc/nginx/sites-available/myblog

# 备份系统配置
echo "备份系统配置..."
sudo tar -czf "$BACKUP_DIR/system_config.tar.gz" /boot/config.txt /etc/fstab

# 创建备份清单
echo "创建备份清单..."
find "$BACKUP_DIR" -type f -exec sha256sum {} \; > "$BACKUP_DIR/checksum.txt"

# 清理旧备份（保留最近7份）
cd "$BACKUP_ROOT"
ls -t | tail -n +8 | xargs -r rm -r

echo "备份完成: $BACKUP_DIR"
```
### 2. 数据恢复流程
```bash
# 创建恢复脚本
nano ~/restore.sh
```
```bash
#!/bin/bash
if [ -z "$1" ]; then
    echo "使用方法: $0 <备份目录>"
    exit 1
fi

BACKUP_DIR="$1"

# 验证备份完整性
echo "验证备份完整性..."
cd "$BACKUP_DIR"
sha256sum -c checksum.txt || {
    echo "备份验证失败！"
    exit 1
}

# 恢复博客内容
echo "恢复博客内容..."
tar -xzf "$BACKUP_DIR/blog_content.tar.gz" -C ~/myblog/
tar -xzf "$BACKUP_DIR/blog_config.tar.gz" -C ~/myblog/

# 恢复 AI 服务
echo "恢复 AI 服务..."
tar -xzf "$BACKUP_DIR/llama_models.tar.gz" -C ~/projects/llama.cpp/
tar -xzf "$BACKUP_DIR/llama_config.tar.gz" -C ~/projects/llama.cpp/

# 恢复 Nginx 配置
echo "恢复 Nginx 配置..."
sudo tar -xzf "$BACKUP_DIR/nginx_config.tar.gz" -C /etc/nginx/sites-available/

# 恢复系统配置
echo "恢复系统配置..."
sudo tar -xzf "$BACKUP_DIR/system_config.tar.gz" -C /

# 重启服务
echo "重启服务..."
sudo systemctl restart nginx
pkill llama-server
~/projects/llama.cpp/start-llama.sh

echo "恢复完成"
```

## 十三、服务升级指南
### 1. Hugo 博客升级
```bash
# 1. 备份当前版本
cd ~
tar -czf hugo_backup_$(date +%Y%m%d).tar.gz myblog/

# 2. 检查当前版本
hugo version

# 3. 下载新版本
wget https://github.com/gohugoio/hugo/releases/download/v[新版本]/hugo_extended_[新版本]_linux-arm64.deb

# 4. 安装新版本
sudo dpkg -i hugo_extended_[新版本]_linux-arm64.deb

# 5. 更新主题
cd ~/myblog
git submodule update --remote themes/ananke

# 6. 测试生成
hugo --verbose

# 7. 部署更新
./deploy-blog.sh
```
### 2. AI 服务升级
```bash
# 1. 备份当前版本
cd ~/projects
tar -czf llama_backup_$(date +%Y%m%d).tar.gz llama.cpp/

# 2. 更新源码
cd llama.cpp
git pull origin master

# 3. 重新编译
make clean
LLAMA_METAL=1 make -j4

# 4. 测试新版本
./llama-server -h

# 5. 更新启动脚本
nano start-llama.sh
```
### 3. 系统升级
```bash
# 1. 更新软件包列表
sudo apt update

# 2. 升级所有包
sudo apt upgrade -y

# 3. 升级系统
sudo apt dist-upgrade -y

# 4. 清理旧包
sudo apt autoremove -y
sudo apt clean

# 5. 检查启动项
sudo systemctl list-unit-files --state=enabled

# 6. 更新树莓派固件
sudo rpi-update

# 7. 检查系统状态
sudo systemctl --failed
sudo journalctl -p 3 -xb
```

## 十四、安全加固指南
### 1. 系统安全配置
```bash
# 1. SSH 安全配置
sudo nano /etc/ssh/sshd_config
```
```toml
# SSH 配置建议
Port 22222                    # 修改默认端口
PermitRootLogin no           # 禁止 root 登录
PasswordAuthentication no    # 禁用密码认证
PubkeyAuthentication yes    # 启用密钥认证
AllowUsers zhaoxiongzhou   # 限制允许的用户
```
```bash
# 2. 设置防火墙规则
sudo apt install ufw fail2ban

# 配置 UFW
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow 22222/tcp  # SSH
sudo ufw allow 80/tcp     # HTTP
sudo ufw allow 8080/tcp   # AI 服务
sudo ufw enable

# 配置 fail2ban
sudo nano /etc/fail2ban/jail.local
```
```bash
[sshd]
enabled = true
port = 22222
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
bantime = 3600
```
### 2. 服务安全配置
#### Nginx 安全设置
```bash
# 1. 创建 SSL 证书
sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
-keyout /etc/nginx/ssl/nginx.key \
-out /etc/nginx/ssl/nginx.crt

# 2. 配置 HTTPS
sudo nano /etc/nginx/sites-available/myblog
```
```toml
server {
    listen 443 ssl;
    server_name 10.40.110.47;

    ssl_certificate /etc/nginx/ssl/nginx.crt;
    ssl_certificate_key /etc/nginx/ssl/nginx.key;
    
    # SSL 配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256;
    
    # 安全头部
    add_header X-Frame-Options "SAMEORIGIN";
    add_header X-XSS-Protection "1; mode=block";
    add_header X-Content-Type-Options "nosniff";
    add_header Strict-Transport-Security "max-age=31536000";

    # 其他配置...
}
```
## 十五、性能监控与分析
### 1. 监控脚本配置
```bash
# 创建综合监控脚本
nano ~/system_monitor.sh
```
```bash
#!/bin/bash
LOG_FILE="/var/log/system_monitor.log"
ALERT_FILE="/var/log/system_alerts.log"

# 记录时间戳
timestamp() {
    date "+%Y-%m-%d %H:%M:%S"
}

# 系统资源监控
monitor_resources() {
    echo "=== 系统资源监控 $(timestamp) ===" >> "$LOG_FILE"
    
    # CPU 使用率
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}')
    echo "CPU 使用率: $CPU_USAGE%" >> "$LOG_FILE"
    
    # 内存使用
    free -h | grep "Mem:" >> "$LOG_FILE"
    
    # 磁盘使用
    df -h / >> "$LOG_FILE"
    
    # 系统负载
    uptime >> "$LOG_FILE"
    
    # CPU 温度
    vcgencmd measure_temp >> "$LOG_FILE"
}

# 服务状态监控
monitor_services() {
    echo "=== 服务状态监控 $(timestamp) ===" >> "$LOG_FILE"
    
    # Nginx 状态
    if systemctl is-active nginx >/dev/null 2>&1; then
        echo "Nginx: 运行中" >> "$LOG_FILE"
    else
        echo "警告: Nginx 未运行!" >> "$ALERT_FILE"
    fi
    
    # AI 服务状态
    if pgrep -f llama-server >/dev/null; then
        echo "AI 服务: 运行中" >> "$LOG_FILE"
    else
        echo "警告: AI 服务未运行!" >> "$ALERT_FILE"
    fi
}

# 网络监控
monitor_network() {
    echo "=== 网络监控 $(timestamp) ===" >> "$LOG_FILE"
    
    # 网络连接数
    netstat -an | grep ESTABLISHED | wc -l >> "$LOG_FILE"
    
    # 网络流量
    ifconfig wlan0 | grep bytes >> "$LOG_FILE"
}

# 主函数
main() {
    monitor_resources
    monitor_services
    monitor_network
    
    # 检查是否需要发送警告
    if [ -s "$ALERT_FILE" ]; then
        # 可以添加发送警告的命令（如邮件通知）
        cat "$ALERT_FILE"
    fi
}

# 执行监控
main
```
### 2. 性能分析工具
```bash
# 安装性能分析工具
sudo apt install sysstat iotop htop

# 创建性能数据收集脚本
nano ~/collect_performance.sh
```

## 十六、性能数据收集与分析
### 1. 性能数据收集脚本
```bash
#!/bin/bash
# ~/collect_performance.sh

PERF_DIR="/home/zhaoxiongzhou/performance_data"
DATE=$(date +%Y%m%d_%H%M%S)

# 创建数据目录
mkdir -p "$PERF_DIR/$DATE"

# CPU 性能数据
mpstat 1 60 > "$PERF_DIR/$DATE/cpu_stats.log" &

# 内存使用数据
vmstat 1 60 > "$PERF_DIR/$DATE/memory_stats.log" &

# IO 性能数据
iostat -x 1 60 > "$PERF_DIR/$DATE/io_stats.log" &

# 网络性能数据
sar -n DEV 1 60 > "$PERF_DIR/$DATE/network_stats.log" &

# 进程性能数据
ps aux --sort=-%cpu | head -n 20 > "$PERF_DIR/$DATE/top_processes.log"

# 系统负载数据
uptime > "$PERF_DIR/$DATE/load_average.log"

# 等待所有后台进程完成
wait

# 压缩数据
tar -czf "$PERF_DIR/performance_${DATE}.tar.gz" "$PERF_DIR/$DATE"
rm -rf "$PERF_DIR/$DATE"
```
### 2. 性能数据分析脚本
```bash
# 创建分析脚本
nano ~/analyze_performance.sh
```
```bash
#!/bin/bash
# ~/analyze_performance.sh

PERF_DIR="/home/zhaoxiongzhou/performance_data"
REPORT_DIR="/home/zhaoxiongzhou/performance_reports"
DATE=$(date +%Y%m%d)

mkdir -p "$REPORT_DIR"

generate_report() {
    local REPORT_FILE="$REPORT_DIR/report_${DATE}.txt"
    echo "性能分析报告 - $(date)" > "$REPORT_FILE"
    echo "===================" >> "$REPORT_FILE"

    # CPU 使用分析
    echo -e "\nCPU 使用情况:" >> "$REPORT_FILE"
    awk '/all/ {total += $3; count++} END {print "平均CPU使用率: " total/count "%"}' \
        "$PERF_DIR/latest/cpu_stats.log" >> "$REPORT_FILE"

    # 内存使用分析
    echo -e "\n内存使用情况:" >> "$REPORT_FILE"
    free -h | grep "Mem:" >> "$REPORT_FILE"

    # IO 性能分析
    echo -e "\nIO 性能:" >> "$REPORT_FILE"
    tail -n 10 "$PERF_DIR/latest/io_stats.log" >> "$REPORT_FILE"

    # 网络性能分析
    echo -e "\n网络性能:" >> "$REPORT_FILE"
    tail -n 10 "$PERF_DIR/latest/network_stats.log" >> "$REPORT_FILE"

    # 进程分析
    echo -e "\n资源占用最高的进程:" >> "$REPORT_FILE"
    head -n 5 "$PERF_DIR/latest/top_processes.log" >> "$REPORT_FILE"

    echo -e "\n分析完成。报告保存在: $REPORT_FILE"
}

# 生成报告
generate_report
```
## 十七、自动化运维脚本
### 1. 服务健康检查与自动恢复
```bash
# 创建服务监控脚本
nano ~/service_health_check.sh
```
```bash
#!/bin/bash
# ~/service_health_check.sh

LOG_FILE="/var/log/service_health.log"
ALERT_SCRIPT="/home/zhaoxiongzhou/send_alert.sh"

log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

check_and_restart_service() {
    local service_name="$1"
    local process_pattern="$2"
    
    if ! pgrep -f "$process_pattern" > /dev/null; then
        log_message "警告: $service_name 服务未运行，尝试重启"
        
        case "$service_name" in
            "nginx")
                sudo systemctl restart nginx
                ;;
            "llama-server")
                cd ~/projects/llama.cpp
                ./start-llama.sh
                ;;
        esac
        
        # 等待服务启动
        sleep 10
        
        # 验证服务是否成功重启
        if pgrep -f "$process_pattern" > /dev/null; then
            log_message "$service_name 服务已成功重启"
            "$ALERT_SCRIPT" "$service_name 服务已自动重启"
        else
            log_message "错误: $service_name 服务重启失败"
            "$ALERT_SCRIPT" "警告: $service_name 服务重启失败，需要手动干预"
        fi
    else
        log_message "$service_name 服务运行正常"
    fi
}

# 检查各个服务
check_and_restart_service "nginx" "nginx"
check_and_restart_service "llama-server" "llama-server"

# 清理旧日志
find "$LOG_FILE" -mtime +30 -delete
```
### 2. 自动备份与清理
```bash
# 创建自动维护脚本
nano ~/auto_maintenance.sh
```
```bash
#!/bin/bash
# ~/auto_maintenance.sh

BACKUP_DIR="/home/zhaoxiongzhou/backups"
LOG_DIR="/var/log"
DATE=$(date +%Y%m%d)

# 创建备份
create_backups() {
    # 博客备份
    tar -czf "$BACKUP_DIR/blog_$DATE.tar.gz" ~/myblog/content
    
    # AI 服务配置备份
    tar -czf "$BACKUP_DIR/llama_config_$DATE.tar.gz" ~/projects/llama.cpp/start-llama.sh
    
    # Nginx 配置备份
    sudo tar -czf "$BACKUP_DIR/nginx_config_$DATE.tar.gz" /etc/nginx/sites-available/
}

# 清理旧文件
cleanup_old_files() {
    # 删除30天前的备份
    find "$BACKUP_DIR" -name "*.tar.gz" -mtime +30 -delete
    
    # 清理日志
    sudo find "$LOG_DIR" -name "*.log" -mtime +30 -delete
    sudo find "$LOG_DIR" -name "*.gz" -mtime +30 -delete
    
    # 清理系统临时文件
    sudo rm -rf /tmp/*
    sudo rm -rf /var/tmp/*
}

# 主函数
main() {
    create_backups
    cleanup_old_files
    
    # 压缩日志
    sudo logrotate -f /etc/logrotate.conf
    
    # 清理包缓存
    sudo apt clean
    sudo apt autoremove -y
}

# 执行维护任务
main
```
## 十八、日志管理系统
### 1. 集中式日志配置
```bash
# 创建日志管理脚本
nano ~/log_management.sh
```
```bash
#!/bin/bash
# ~/log_management.sh

LOG_BASE="/var/log/services"
ARCHIVE_DIR="/home/zhaoxiongzhou/log_archives"
DATE=$(date +%Y%m%d)

# 创建日志目录
mkdir -p "$LOG_BASE"/{nginx,ai_service,system}
mkdir -p "$ARCHIVE_DIR"

# 配置日志轮转
sudo tee /etc/logrotate.d/custom_services << EOF
$LOG_BASE/nginx/*.log {
    daily
    missingok
    rotate 14
    compress
    delaycompress
    notifempty
    create 0640 www-data adm
    sharedscripts
    postrotate
        [ -f /var/run/nginx.pid ] && kill -USR1 \$(cat /var/run/nginx.pid)
    endscript
}

$LOG_BASE/ai_service/*.log {
    daily
    missingok
    rotate 14
    compress
    delaycompress
    notifempty
    create 0640 zhaoxiongzhou adm
}

$LOG_BASE/system/*.log {
    daily
    missingok
    rotate 30
    compress
    delaycompress
    notifempty
    create 0640 root adm
}
EOF

# 日志分析函数
analyze_logs() {
    local log_file="$1"
    local output_file="$2"
    
    echo "=== 日志分析报告 $(date) ===" > "$output_file"
    
    # 错误统计
    echo -e "\n错误统计:" >> "$output_file"
    grep -i "error" "$log_file" | sort | uniq -c | sort -nr >> "$output_file"
    
    # 警告统计
    echo -e "\n警告统计:" >> "$output_file"
    grep -i "warning" "$log_file" | sort | uniq -c | sort -nr >> "$output_file"
    
    # 访问统计（针对 Nginx 访问日志）
    if [[ "$log_file" == *"nginx/access"* ]]; then
        echo -e "\n访问量统计:" >> "$output_file"
        awk '{print $1}' "$log_file" | sort | uniq -c | sort -nr | head -n 10 >> "$output_file"
    fi
}

# 日志归档函数
archive_logs() {
    local source_dir="$1"
    local archive_name="logs_${DATE}.tar.gz"
    
    find "$source_dir" -name "*.log.*" -mtime +14 -exec tar -czf "$ARCHIVE_DIR/$archive_name" {} +
    find "$source_dir" -name "*.log.*" -mtime +14 -delete
}
```
### 2. 日志监控告警
```bash
# 创建日志监控脚本
nano ~/log_monitor.sh
```
```bash
#!/bin/bash
# ~/log_monitor.sh

ALERT_THRESHOLD=10  # 错误阈值
ALERT_SCRIPT="/home/zhaoxiongzhou/send_alert.sh"

# 监控特定关键词
monitor_keywords() {
    local log_file="$1"
    local keywords=("error" "critical" "failed" "timeout" "exception")
    
    for keyword in "${keywords[@]}"; do
        count=$(grep -i "$keyword" "$log_file" | wc -l)
        
        if [ "$count" -gt "$ALERT_THRESHOLD" ]; then
            "$ALERT_SCRIPT" "警告: $log_file 中发现大量 $keyword ($count 次)"
        fi
    done
}

# 监控日志大小
check_log_size() {
    local log_file="$1"
    local max_size=$((100 * 1024 * 1024))  # 100MB
    
    size=$(stat -f%z "$log_file")
    
    if [ "$size" -gt "$max_size" ]; then
        "$ALERT_SCRIPT" "警告: $log_file 大小超过 100MB"
    fi
}

# 主监控循环
main() {
    while true; do
        for log_file in "$LOG_BASE"/**/*.log; do
            monitor_keywords "$log_file"
            check_log_size "$log_file"
        done
        sleep 300  # 每5分钟检查一次
    done
}

main &
```
## 十九、系统优化与调优
### 1. 系统参数优化
```bash
# 创建系统优化脚本
nano ~/system_optimize.sh
```
```bash
#!/bin/bash
# ~/system_optimize.sh

# 系统参数优化
optimize_sysctl() {
    sudo tee /etc/sysctl.d/99-custom.conf << EOF
# 内存管理优化
vm.swappiness = 60
vm.vfs_cache_pressure = 50
vm.dirty_background_ratio = 5
vm.dirty_ratio = 10

# 网络优化
net.core.somaxconn = 1024
net.core.netdev_max_backlog = 5000
net.ipv4.tcp_max_syn_backlog = 2048
net.ipv4.tcp_fin_timeout = 20
net.ipv4.tcp_keepalive_time = 1200
net.ipv4.tcp_keepalive_intvl = 15
net.ipv4.tcp_keepalive_probes = 5

# 文件系统优化
fs.file-max = 65535
fs.inotify.max_user_watches = 524288
EOF

    # 应用新的系统参数
    sudo sysctl -p /etc/sysctl.d/99-custom.conf
}

# CPU 频率优化
optimize_cpu() {
    sudo tee /boot/config.txt << EOF
# CPU 设置
arm_freq=1800
over_voltage=6
gpu_freq=500

# 温度控制
temp_limit=75
EOF
}

# 服务优化
optimize_services() {
    # 禁用不必要的服务
    UNNECESSARY_SERVICES=(
        "bluetooth"
        "cups"
        "avahi-daemon"
    )
    
    for service in "${UNNECESSARY_SERVICES[@]}"; do
        if systemctl is-enabled "$service" &>/dev/null; then
            sudo systemctl disable "$service"
            sudo systemctl stop "$service"
        fi
    done
}

# 内存优化
optimize_memory() {
    # 调整 ZRAM
    sudo tee /etc/default/zramswap << EOF
ALGO=lz4
PERCENT=50
EOF

    # 重启 ZRAM 服务
    sudo systemctl restart zramswap
}
```
### 2. 服务优化配置
```bash
# Nginx 优化配置
sudo nano /etc/nginx/nginx.conf
```
```toml
user www-data;
worker_processes auto;
worker_rlimit_nofile 65535;

events {
    worker_connections 1024;
    multi_accept on;
    use epoll;
}

http {
    # 基础设置
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_tokens off;

    # MIME 类型
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';

    # 缓冲区设置
    client_body_buffer_size 10K;
    client_header_buffer_size 1k;
    client_max_body_size 8m;
    large_client_header_buffers 2 1k;

    # 超时设置
    client_body_timeout 12;
    client_header_timeout 12;
    send_timeout 10;

    # 缓存设置
    open_file_cache max=1000 inactive=20s;
    open_file_cache_valid 30s;
    open_file_cache_min_uses 2;
    open_file_cache_errors on;

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css text/xml application/json application/javascript application/xml+rss application/atom+xml image/svg+xml;
}
```
## 二十、服务监控面板配置
### 1. Grafana 监控系统配置
```bash
# 安装 Grafana
sudo apt-get install -y apt-transport-https
sudo apt-get install -y software-properties-common wget
wget -q -O - https://packages.grafana.com/gpg.key | sudo apt-key add -
echo "deb https://packages.grafana.com/oss/deb stable main" | sudo tee -a /etc/apt/sources.list.d/grafana.list
sudo apt-get update
sudo apt-get install -y grafana
```
```bash
# 配置 Grafana
sudo nano /etc/grafana/grafana.ini
```
```toml
[server]
http_addr = 0.0.0.0
http_port = 3000

[security]
admin_user = admin
admin_password = your_secure_password

[auth.anonymous]
enabled = false

[paths]
data = /var/lib/grafana
logs = /var/log/grafana
plugins = /var/lib/grafana/plugins

[dashboards]
versions_to_keep = 20
```
### 2. Prometheus 配置
```bash
# 安装 Prometheus
sudo apt-get install -y prometheus

# 配置 Prometheus
sudo nano /etc/prometheus/prometheus.yml
```
```yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'node'
    static_configs:
      - targets: ['localhost:9100']
    
  - job_name: 'nginx'
    static_configs:
      - targets: ['localhost:9113']
    
  - job_name: 'system'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'process'
    static_configs:
      - targets: ['localhost:9256']
```
### 3. Node Exporter 配置
```bash
# 安装 Node Exporter
sudo apt-get install -y prometheus-node-exporter

# 创建自定义指标收集脚本
nano ~/custom_metrics.sh
```
```bash
#!/bin/bash
# ~/custom_metrics.sh

# 创建指标文件
METRICS_FILE="/var/lib/node_exporter/custom_metrics.prom"

while true; do
    # CPU 温度
    CPU_TEMP=$(vcgencmd measure_temp | sed 's/temp=//' | sed 's/'"'"'C//')
    echo "raspberry_pi_cpu_temperature $CPU_TEMP" > "$METRICS_FILE"

    # AI 服务状态
    if pgrep -f llama-server > /dev/null; then
        echo "ai_service_status 1" >> "$METRICS_FILE"
    else
        echo "ai_service_status 0" >> "$METRICS_FILE"
    fi

    # 博客服务状态
    if systemctl is-active nginx > /dev/null; then
        echo "blog_service_status 1" >> "$METRICS_FILE"
    else
        echo "blog_service_status 0" >> "$METRICS_FILE"
    fi

    # 内存使用
    FREE_MEM=$(free | grep Mem | awk '{print $4}')
    echo "system_free_memory_bytes $FREE_MEM" >> "$METRICS_FILE"

    sleep 15
done
```
## 二十一、自动化部署与更新
### 1. 自动部署配置脚本
```bash
# 创建自动部署脚本
nano ~/auto_deploy.sh
```
```bash
#!/bin/bash
# ~/auto_deploy.sh

# 配置
BLOG_DIR="/home/zhaoxiongzhou/myblog"
LLAMA_DIR="/home/zhaoxiongzhou/projects/llama.cpp"
BACKUP_DIR="/home/zhaoxiongzhou/backups"
LOG_FILE="/var/log/auto_deploy.log"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# 备份当前版本
backup_current() {
    log "开始备份当前版本"
    
    # 博客备份
    tar -czf "$BACKUP_DIR/blog_$(date +%Y%m%d_%H%M%S).tar.gz" "$BLOG_DIR"
    
    # AI 服务备份
    tar -czf "$BACKUP_DIR/llama_$(date +%Y%m%d_%H%M%S).tar.gz" "$LLAMA_DIR"
    
    log "备份完成"
}

# 更新博客
update_blog() {
    log "开始更新博客"
    
    cd "$BLOG_DIR" || exit 1
    
    # 拉取最新代码
    if git pull origin master; then
        # 更新主题
        git submodule update --remote themes/ananke
        
        # 构建站点
        hugo --minify
        
        # 更新权限
        sudo chown -R www-data:www-data public/
        
        # 重启 Nginx
        sudo systemctl restart nginx
        
        log "博客更新成功"
    else
        log "错误: 博客更新失败"
        return 1
    fi
}

# 更新 AI 服务
update_ai_service() {
    log "开始更新 AI 服务"
    
    cd "$LLAMA_DIR" || exit 1
    
    # 停止当前服务
    pkill llama-server
    
    # 拉取最新代码
    if git pull origin master; then
        # 重新编译
        make clean
        if LLAMA_METAL=1 make -j4; then
            # 启动服务
            ./start-llama.sh
            
            # 验证服务
            sleep 5
            if pgrep -f llama-server > /dev/null; then
                log "AI 服务更新成功"
            else
                log "错误: AI 服务启动失败"
                return 1
            fi
        else
            log "错误: AI 服务编译失败"
            return 1
        fi
    else
        log "错误: AI 服务代码更新失败"
        return 1
    fi
}

# 主函数
main() {
    log "开始自动部署流程"
    
    # 创建备份
    backup_current
    
    # 更新服务
    if update_blog && update_ai_service; then
        log "部署完成"
        return 0
    else
        log "部署失败"
        return 1
    fi
}

# 执行部署
main
```
### 2. 自动更新检查脚本
```bash
# 创建更新检查脚本
nano ~/check_updates.sh
```
## 二十一、自动更新检查与通知系统
### 1. 更新检查脚本
```bash
#!/bin/bash
# ~/check_updates.sh

# 配置
NOTIFY_SCRIPT="/home/zhaoxiongzhou/send_notification.sh"
LOG_FILE="/var/log/update_check.log"
GITHUB_API="https://api.github.com"
LLAMA_REPO="ggerganov/llama.cpp"
HUGO_REPO="gohugoio/hugo"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 检查 GitHub 仓库更新
check_github_updates() {
    local repo="$1"
    local current_version="$2"
    
    # 获取最新版本
    latest_version=$(curl -s "$GITHUB_API/repos/$repo/releases/latest" | grep -Po '"tag_name": "\K.*?(?=")')
    
    if [ "$latest_version" != "$current_version" ]; then
        log "发现新版本: $repo ($current_version -> $latest_version)"
        return 0
    else
        log "当前版本已是最新: $repo ($current_version)"
        return 1
    fi
}

# 检查系统更新
check_system_updates() {
    sudo apt update > /dev/null 2>&1
    updates=$(sudo apt list --upgradable 2>/dev/null | grep -c "upgradable")
    
    if [ "$updates" -gt 0 ]; then
        log "发现 $updates 个系统更新"
        return 0
    else
        log "系统已是最新"
        return 1
    fi
}

# 检查服务状态
check_services() {
    local services=("nginx" "llama-server")
    local status=0
    
    for service in "${services[@]}"; do
        if [ "$service" = "nginx" ]; then
            if ! systemctl is-active --quiet nginx; then
                log "警告: Nginx 服务未运行"
                status=1
            fi
        elif [ "$service" = "llama-server" ]; then
            if ! pgrep -f llama-server > /dev/null; then
                log "警告: AI 服务未运行"
                status=1
            fi
        fi
    done
    
    return $status
}

# 发送通知
send_notification() {
    local message="$1"
    local priority="$2"
    
    if [ -x "$NOTIFY_SCRIPT" ]; then
        "$NOTIFY_SCRIPT" "$message" "$priority"
    else
        log "通知脚本不存在或不可执行"
    fi
}

# 主函数
main() {
    log "开始检查更新"
    
    # 获取当前版本
    current_llama_version=$(cd ~/projects/llama.cpp && git describe --tags)
    current_hugo_version=$(hugo version | grep -Po "v\d+\.\d+\.\d+")
    
    # 检查更新
    updates_found=0
    
    if check_github_updates "$LLAMA_REPO" "$current_llama_version"; then
        send_notification "llama.cpp 有新版本可用" "normal"
        updates_found=1
    fi
    
    if check_github_updates "$HUGO_REPO" "$current_hugo_version"; then
        send_notification "Hugo 有新版本可用" "normal"
        updates_found=1
    fi
    
    if check_system_updates; then
        send_notification "系统有更新可用" "normal"
        updates_found=1
    fi
    
    if ! check_services; then
        send_notification "服务状态异常，请检查" "high"
    fi
    
    if [ "$updates_found" -eq 0 ]; then
        log "所有组件均为最新版本"
    fi
}

# 执行检查
main
```
## 二十二、通知系统配置
### 1. 通知发送脚本
```bash
# 创建通知发送脚本
nano ~/send_notification.sh
```
```bash
#!/bin/bash
# ~/send_notification.sh

# 配置
TELEGRAM_BOT_TOKEN="your_bot_token"
TELEGRAM_CHAT_ID="your_chat_id"
EMAIL_ADDRESS="your_email@domain.com"
DISCORD_WEBHOOK_URL="your_discord_webhook_url"

# 日志配置
LOG_FILE="/var/log/notifications.log"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Telegram 通知
send_telegram() {
    local message="$1"
    local priority="$2"
    
    # 根据优先级添加表情符号
    case "$priority" in
        "high")
            message="🚨 紧急: $message"
            ;;
        "normal")
            message="ℹ️ 通知: $message"
            ;;
        "low")
            message="📝 信息: $message"
            ;;
    esac
    
    # 发送消息
    curl -s -X POST \
        "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
        -d "chat_id=$TELEGRAM_CHAT_ID" \
        -d "text=$message" \
        -d "parse_mode=HTML"
    
    log "Telegram 通知已发送: $message"
}

# 邮件通知
send_email() {
    local message="$1"
    local priority="$2"
    local subject
    
    case "$priority" in
        "high")
            subject="[紧急] 树莓派服务警告"
            ;;
        "normal")
            subject="[通知] 树莓派服务更新"
            ;;
        "low")
            subject="[信息] 树莓派服务状态"
            ;;
    esac
    
    echo "$message" | mail -s "$subject" "$EMAIL_ADDRESS"
    log "邮件通知已发送: $subject - $message"
}

# Discord 通知
send_discord() {
    local message="$1"
    local priority="$2"
    local color
    
    case "$priority" in
        "high")
            color="16711680"  # 红色
            ;;
        "normal")
            color="65280"     # 绿色
            ;;
        "low")
            color="255"       # 蓝色
            ;;
    esac
    
    curl -H "Content-Type: application/json" \
        -X POST \
        -d "{\"embeds\": [{\"description\": \"$message\", \"color\": $color}]}" \
        "$DISCORD_WEBHOOK_URL"
    
    log "Discord 通知已发送: $message"
}

# 主函数
main() {
    local message="$1"
    local priority="${2:-normal}"  # 默认优先级为 normal
    
    # 检查必要参数
    if [ -z "$message" ]; then
        log "错误: 消息内容不能为空"
        return 1
    fi
    
    # 添加系统信息
    local hostname=$(hostname)
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    message="[$hostname] [$timestamp] $message"
    
    # 发送所有通知
    send_telegram "$message" "$priority"
    send_email "$message" "$priority"
    send_discord "$message" "$priority"
    
    log "所有通知渠道处理完成"
}

# 执行通知发送
main "$@"
```
## 二十三、定时任务配置
### 1. Crontab 配置
```bash
# 编辑 crontab
crontab -e
```
```bash
# 系统维护任务
# 每天凌晨 2 点执行系统更新检查
0 2 * * * ~/check_updates.sh > /dev/null 2>&1

# 每 6 小时执行一次服务健康检查
0 */6 * * * ~/service_health_check.sh > /dev/null 2>&1

# 每周日凌晨 3 点执行系统优化
0 3 * * 0 ~/system_optimize.sh > /dev/null 2>&1

# 每天凌晨 4 点执行日志管理
0 4 * * * ~/log_management.sh > /dev/null 2>&1

# 每小时执行性能数据收集
0 * * * * ~/collect_performance.sh > /dev/null 2>&1

# 每 5 分钟检查一次关键服务状态
*/5 * * * * ~/monitor.sh > /dev/null 2>&1

# 每天晚上 11 点执行备份
0 23 * * * ~/auto_backup.sh > /dev/null 2>&1

# 每月 1 号执行完整系统检查
0 1 1 * * ~/full_system_check.sh > /dev/null 2>&1
```
### 2. 完整系统检查脚本
```bash
# 创建完整系统检查脚本
nano ~/full_system_check.sh
```
```bash
#!/bin/bash
# ~/full_system_check.sh

LOG_FILE="/var/log/system_check.log"
REPORT_FILE="/home/zhaoxiongzhou/reports/monthly_report_$(date +%Y%m).txt"

# 确保目录存在
mkdir -p "$(dirname "$REPORT_FILE")"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE" "$REPORT_FILE"
}

# 系统信息检查
check_system_info() {
    log "=== 系统信息 ==="
    log "系统版本: $(cat /etc/os-release | grep PRETTY_NAME)"
    log "内核版本: $(uname -r)"
    log "运行时间: $(uptime -p)"
    log "最后启动: $(who -b | awk '{print $3,$4}')"
}

# 资源使用检查
check_resources() {
    log "=== 资源使用情况 ==="
    log "CPU 使用率: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}')%"
    log "内存使用情况:"
    free -h | tee -a "$REPORT_FILE"
    log "磁盘使用情况:"
    df -h | tee -a "$REPORT_FILE"
}

# 服务状态检查
check_services() {
    log "=== 服务状态 ==="
    
    # 检查 Nginx
    if systemctl is-active --quiet nginx; then
        log "Nginx: 运行正常"
    else
        log "Nginx: 未运行"
    fi
    
    # 检查 AI 服务
    if pgrep -f llama-server > /dev/null; then
        log "AI 服务: 运行正常"
    else
        log "AI 服务: 未运行"
    fi
}

# 安全检查
check_security() {
    log "=== 安全检查 ==="
    
    # 检查失败的登录尝试
    log "失败的登录尝试:"
    grep "Failed password" /var/log/auth.log | tail -n 5 | tee -a "$REPORT_FILE"
    
    # 检查开放的端口
    log "开放的端口:"
    netstat -tuln | grep LISTEN | tee -a "$REPORT_FILE"
}

# 性能分析
analyze_performance() {
    log "=== 性能分析 ==="
    
    # 分析 CPU 使用情况
    log "CPU 密集进程:"
    ps aux --sort=-%cpu | head -n 5 | tee -a "$REPORT_FILE"
    
    # 分析内存使用情况
    log "内存密集进程:"
    ps aux --sort=-%mem | head -n 5 | tee -a "$REPORT_FILE"
}

# 主函数
main() {
    log "开始月度系统检查 - $(date)"
    
    check_system_info
    check_resources
    check_services
    check_security
    analyze_performance
    
    log "系统检查完成"
    
    # 发送报告
    if [ -f "$REPORT_FILE" ]; then
        ~/send_notification.sh "月度系统检查报告已生成" "normal"
    fi
}

# 执行检查
main
```
## 二十四、灾难恢复计划
### 1. 系统恢复脚本
```bash
# 创建系统恢复脚本
nano ~/disaster_recovery.sh
```
```bash
#!/bin/bash
# ~/disaster_recovery.sh

# 配置
BACKUP_DIR="/home/zhaoxiongzhou/backups"
RECOVERY_LOG="/var/log/recovery.log"
SERVICES=("nginx" "llama-server")

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$RECOVERY_LOG"
}

# 验证备份
verify_backup() {
    local backup_file="$1"
    
    if [ ! -f "$backup_file" ]; then
        log "错误: 备份文件不存在 - $backup_file"
        return 1
    fi
    
    # 检查文件完整性
    if ! tar -tzf "$backup_file" >/dev/null 2>&1; then
        log "错误: 备份文件损坏 - $backup_file"
        return 1
    fi
    
    return 0
}

# 停止服务
stop_services() {
    log "停止所有服务..."
    
    for service in "${SERVICES[@]}"; do
        if [ "$service" = "nginx" ]; then
            sudo systemctl stop nginx
        else
            pkill "$service"
        fi
    done
    
    # 等待服务完全停止
    sleep 5
}

# 恢复博客服务
restore_blog() {
    local backup_file="$BACKUP_DIR/blog_latest.tar.gz"
    
    if verify_backup "$backup_file"; then
        log "开始恢复博客服务..."
        
        # 清理当前目录
        rm -rf ~/myblog/*
        
        # 解压备份
        tar -xzf "$backup_file" -C ~/myblog/
        
        # 重建站点
        cd ~/myblog
        hugo --minify
        
        # 恢复权限
        sudo chown -R www-data:www-data public/
        
        log "博客服务恢复完成"
    else
        log "博客服务恢复失败"
        return 1
    fi
}

# 恢复 AI 服务
restore_ai_service() {
    local backup_file="$BACKUP_DIR/llama_latest.tar.gz"
    
    if verify_backup "$backup_file"; then
        log "开始恢复 AI 服务..."
        
        # 清理当前目录
        rm -rf ~/projects/llama.cpp/*
        
        # 解压备份
        tar -xzf "$backup_file" -C ~/projects/llama.cpp/
        
        # 重新编译
        cd ~/projects/llama.cpp
        make clean
        LLAMA_METAL=1 make -j4
        
        log "AI 服务恢复完成"
    else
        log "AI 服务恢复失败"
        return 1
    fi
}

# 恢复系统配置
restore_system_config() {
    local backup_file="$BACKUP_DIR/system_config_latest.tar.gz"
    
    if verify_backup "$backup_file"; then
        log "开始恢复系统配置..."
        
        # 解压系统配置
        sudo tar -xzf "$backup_file" -C /
        
        # 重新加载系统配置
        sudo sysctl --system
        
        log "系统配置恢复完成"
    else
        log "系统配置恢复失败"
        return 1
    fi
}

# 启动服务
start_services() {
    log "启动所有服务..."
    
    # 启动 Nginx
    sudo systemctl start nginx
    
    # 启动 AI 服务
    ~/projects/llama.cpp/start-llama.sh
    
    # 验证服务状态
    sleep 10
    verify_services
}

# 验证服务
verify_services() {
    local status=0
    
    log "验证服务状态..."
    
    # 检查 Nginx
    if ! systemctl is-active --quiet nginx; then
        log "警告: Nginx 服务未正常运行"
        status=1
    fi
    
    # 检查 AI 服务
    if ! pgrep -f llama-server > /dev/null; then
        log "警告: AI 服务未正常运行"
        status=1
    fi
    
    return $status
}

# 主函数
main() {
    log "开始系统恢复流程..."
    
    # 停止服务
    stop_services
    
    # 执行恢复
    if restore_system_config && restore_blog && restore_ai_service; then
        # 启动服务
        start_services
        
        if verify_services; then
            log "系统恢复成功完成"
            ~/send_notification.sh "系统恢复成功完成" "normal"
            return 0
        else
            log "系统恢复完成，但部分服务可能未正常运行"
            ~/send_notification.sh "系统恢复完成，但需要手动检查服务状态" "high"
            return 1
        fi
    else
        log "系统恢复失败"
        ~/send_notification.sh "系统恢复失败，需要手动干预" "high"
        return 1
    fi
}

# 执行恢复
main
```
## 二十五、文档管理系统
### 1. 文档生成脚本
```bash
# 创建文档生成脚本
nano ~/generate_docs.sh
```
```bash
#!/bin/bash
# ~/generate_docs.sh

# 配置
DOCS_DIR="/home/zhaoxiongzhou/documentation"
SCRIPTS_DIR="/home/zhaoxiongzhou"
CONFIG_DIR="/etc"
LOG_FILE="/var/log/documentation.log"

# 确保目录存在
mkdir -p "$DOCS_DIR"/{scripts,configs,logs,maintenance}

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 生成脚本文档
generate_script_docs() {
    log "生成脚本文档..."
    
    for script in "$SCRIPTS_DIR"/*.sh; do
        if [ -f "$script" ]; then
            script_name=$(basename "$script")
            output_file="$DOCS_DIR/scripts/${script_name%.sh}.md"
            
            {
                echo "# $script_name"
                echo "## 路径: $script"
                echo "## 最后修改: $(date -r "$script" '+%Y-%m-%d %H:%M:%S')"
                echo "## 权限: $(stat -c '%a' "$script")"
                echo "## 所有者: $(stat -c '%U:%G' "$script")"
                echo
                echo "## 功能描述"
                grep -A 5 "^#.*功能:" "$script" 2>/dev/null || echo "未提供功能描述"
                echo
                echo "## 脚本内容"
                echo '```bash'
                cat "$script"
                echo '```'
                echo
                echo "## 依赖项"
                grep "^[^#]*apt.*install" "$script" 2>/dev/null || echo "未找到明确的依赖项"
                echo
                echo "## 定时任务"
                crontab -l 2>/dev/null | grep "$script_name" || echo "未配置定时任务"
            } > "$output_file"
        fi
    done
}

# 生成配置文档
generate_config_docs() {
    log "生成配置文档..."
    
    # Nginx 配置
    {
        echo "# Nginx 配置文档"
        echo "## 主配置文件"
        echo '```nginx'
        cat /etc/nginx/nginx.conf
        echo '```'
        
        echo "## 站点配置"
        echo '```nginx'
        cat /etc/nginx/sites-available/myblog
        echo '```'
    } > "$DOCS_DIR/configs/nginx_config.md"
    
    # 系统配置
    {
        echo "# 系统配置文档"
        echo "## Sysctl 配置"
        echo '```bash'
        cat /etc/sysctl.d/99-custom.conf
        echo '```'
        
        echo "## 树莓派配置"
        echo '```bash'
        cat /boot/config.txt
        echo '```'
    } > "$DOCS_DIR/configs/system_config.md"
}

# 生成维护文档
generate_maintenance_docs() {
    log "生成维护文档..."
    
    {
        echo "# 系统维护文档"
        echo "## 定时任务"
        echo '```bash'
        crontab -l
        echo '```'
        
        echo "## 服务状态"
        echo '```bash'
        systemctl status nginx
        ps aux | grep llama-server
        echo '```'
        
        echo "## 资源使用"
        echo '```bash'
        df -h
        free -h
        top -bn1
        echo '```'
        
        echo "## 最近日志"
        echo '```bash'
        tail -n 50 /var/log/syslog
        echo '```'
    } > "$DOCS_DIR/maintenance/system_status.md"
}

# 生成索引
generate_index() {
    log "生成文档索引..."
    
    {
        echo "# 系统文档索引"
        echo "## 生成时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo
        echo "## 脚本文档"
        for doc in "$DOCS_DIR/scripts"/*.md; do
            echo "- [$(basename "${doc%.md}")](scripts/$(basename "$doc"))"
        done
        echo
        echo "## 配置文档"
        for doc in "$DOCS_DIR/configs"/*.md; do
            echo "- [$(basename "${doc%.md}")](configs/$(basename "$doc"))"
        done
        echo
        echo "## 维护文档"
        for doc in "$DOCS_DIR/maintenance"/*.md; do
            echo "- [$(basename "${doc%.md}")](maintenance/$(basename "$doc"))"
        done
    } > "$DOCS_DIR/index.md"
}

# 主函数
main() {
    log "开始生成文档..."
    
    generate_script_docs
    generate_config_docs
    generate_maintenance_docs
    generate_index
    
    log "文档生成完成: $DOCS_DIR"
}

# 执行文档生成
main
```
## 二十六、性能测试与基准测试
### 1. 性能测试脚本
```bash
# 创建性能测试脚本
nano ~/benchmark.sh
```
```bash
#!/bin/bash
# ~/benchmark.sh

# 配置
RESULTS_DIR="/home/zhaoxiongzhou/benchmark_results"
LOG_FILE="/var/log/benchmark.log"
DURATION=300  # 测试持续时间（秒）
CONCURRENT_USERS=10  # 并发用户数

# 确保目录存在
mkdir -p "$RESULTS_DIR"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# CPU 性能测试
benchmark_cpu() {
    log "开始 CPU 性能测试..."
    
    # 使用 sysbench 进行 CPU 测试
    sysbench cpu --cpu-max-prime=20000 --threads=4 run > "$RESULTS_DIR/cpu_benchmark.txt"
    
    # 记录 CPU 温度
    for i in $(seq 1 10); do
        vcgencmd measure_temp >> "$RESULTS_DIR/cpu_temp.txt"
        sleep 1
    done
}

# 内存性能测试
benchmark_memory() {
    log "开始内存性能测试..."
    
    # 使用 sysbench 进行内存测试
    sysbench memory --memory-block-size=1K --memory-total-size=10G run > "$RESULTS_DIR/memory_benchmark.txt"
}

# 磁盘性能测试
benchmark_disk() {
    log "开始磁盘性能测试..."
    
    # 使用 dd 测试写入速度
    dd if=/dev/zero of=/tmp/test_file bs=1M count=1000 conv=fdatasync 2>> "$RESULTS_DIR/disk_write_benchmark.txt"
    
    # 使用 dd 测试读取速度
    dd if=/tmp/test_file of=/dev/null bs=1M count=1000 2>> "$RESULTS_DIR/disk_read_benchmark.txt"
    
    # 清理测试文件
    rm /tmp/test_file
}

# 网络性能测试
benchmark_network() {
    log "开始网络性能测试..."
    
    # 使用 iperf3 测试网络性能
    iperf3 -c iperf.he.net -t 30 > "$RESULTS_DIR/network_benchmark.txt"
}

# Web 服务性能测试
benchmark_web() {
    log "开始 Web 服务性能测试..."
    
    # 使用 ab 测试 Web 服务
    ab -n 1000 -c "$CONCURRENT_USERS" http://localhost/ > "$RESULTS_DIR/web_benchmark.txt"
}

# AI 服务性能测试
benchmark_ai() {
    log "开始 AI 服务性能测试..."
    
    # 创建测试请求
    cat > /tmp/test_prompt.txt << EOF
Hello, how are you?
EOF
    
    # 使用 curl 测试 AI 服务响应时间
    for i in $(seq 1 10); do
        time curl -X POST \
             -H "Content-Type: application/json" \
             -d @/tmp/test_prompt.txt \
             http://localhost:8080/completion >> "$RESULTS_DIR/ai_benchmark.txt" 2>&1
        echo -e "\n---\n" >> "$RESULTS_DIR/ai_benchmark.txt"
        sleep 2
    done
}

# 生成报告
generate_report() {
    log "生成性能测试报告..."
    
    local report_file="$RESULTS_DIR/benchmark_report_$(date +%Y%m%d_%H%M%S).md"
    
    {
        echo "# 性能测试报告"
        echo "## 测试时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo
        echo "## 系统信息"
        echo '```'
        uname -a
        echo '```'
        echo
        echo "## CPU 性能"
        echo '```'
        cat "$RESULTS_DIR/cpu_benchmark.txt"
        echo '```'
        echo
        echo "## 内存性能"
        echo '```'
        cat "$RESULTS_DIR/memory_benchmark.txt"
        echo '```'
        echo
        echo "## 磁盘性能"
        echo '```'
        cat "$RESULTS_DIR/disk_write_benchmark.txt"
        cat "$RESULTS_DIR/disk_read_benchmark.txt"
        echo '```'
        echo
        echo "## 网络性能"
        echo '```'
        cat "$RESULTS_DIR/network_benchmark.txt"
        echo '```'
        echo
        echo "## Web 服务性能"
        echo '```'
        cat "$RESULTS_DIR/web_benchmark.txt"
        echo '```'
        echo
        echo "## AI 服务性能"
        echo '```'
        cat "$RESULTS_DIR/ai_benchmark.txt"
        echo '```'
    } > "$report_file"
    
    log "性能测试报告已生成: $report_file"
}

# 主函数
main() {
    log "开始性能测试..."
    
    # 安装必要的工具
    sudo apt install -y sysbench apache2-utils iperf3
    
    # 执行各项测试
    benchmark_cpu
    benchmark_memory
    benchmark_disk
    benchmark_network
    benchmark_web
    benchmark_ai
    
    # 生成报告
    generate_report
    
    log "性能测试完成"
}

# 执行测试
main
```
## 二十七、安全审计系统
### 1. 安全审计脚本
```bash
# 创建安全审计脚本
nano ~/security_audit.sh
```
```bash
#!/bin/bash
# ~/security_audit.sh

# 配置
AUDIT_DIR="/home/zhaoxiongzhou/security_audits"
REPORT_FILE="$AUDIT_DIR/security_report_$(date +%Y%m%d_%H%M%S).md"
LOG_FILE="/var/log/security_audit.log"

# 确保目录存在
mkdir -p "$AUDIT_DIR"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 检查系统用户
audit_users() {
    log "检查系统用户..."
    {
        echo "## 系统用户审计"
        echo "### 特权用户"
        echo '```'
        awk -F: '$3 == 0 {print $1}' /etc/passwd
        echo '```'
        
        echo "### 最近的用户活动"
        echo '```'
        last | head -n 10
        echo '```'
        
        echo "### 失败的登录尝试"
        echo '```'
        grep "Failed password" /var/log/auth.log | tail -n 10
        echo '```'
    } >> "$REPORT_FILE"
}

# 检查网络安全
audit_network() {
    log "检查网络安全..."
    {
        echo "## 网络安全审计"
        echo "### 开放端口"
        echo '```'
        netstat -tuln
        echo '```'
        
        echo "### 活动连接"
        echo '```'
        netstat -nat | grep ESTABLISHED
        echo '```'
        
        echo "### 防火墙规则"
        echo '```'
        sudo iptables -L -n
        echo '```'
    } >> "$REPORT_FILE"
}

# 检查文件权限
audit_permissions() {
    log "检查文件权限..."
    {
        echo "## 文件权限审计"
        echo "### SUID 文件"
        echo '```'
        sudo find / -type f -perm -4000 2>/dev/null
        echo '```'
        
        echo "### 世界可写文件"
        echo '```'
        sudo find / -type f -perm -2 ! -path "/proc/*" ! -path "/sys/*" 2>/dev/null
        echo '```'
        
        echo "### 敏感目录权限"
        echo '```'
        ls -la /etc/nginx/
        ls -la ~/projects/llama.cpp/
        ls -la ~/myblog/
        echo '```'
    } >> "$REPORT_FILE"
}

# 检查服务配置
audit_services() {
    log "检查服务配置..."
    {
        echo "## 服务配置审计"
        echo "### Nginx 配置检查"
        echo '```'
        sudo nginx -t 2>&1
        echo '```'
        
        echo "### SSL 配置"
        echo '```'
        openssl s_client -connect localhost:443 -servername localhost </dev/null 2>/dev/null | openssl x509 -text
        echo '```'
        
        echo "### 服务状态"
        echo '```'
        systemctl list-units --type=service --state=active
        echo '```'
    } >> "$REPORT_FILE"
}

# 检查系统更新
audit_updates() {
    log "检查系统更新..."
    {
        echo "## 系统更新审计"
        echo "### 可用更新"
        echo '```'
        apt list --upgradable 2>/dev/null
        echo '```'
        
        echo "### 已安装包"
        echo '```'
        dpkg -l | grep "^ii" | wc -l
        echo '```'
    } >> "$REPORT_FILE"
}

# 检查日志异常
audit_logs() {
    log "检查日志异常..."
    {
        echo "## 日志审计"
        echo "### 系统错误"
        echo '```'
        sudo journalctl -p 3 -xb --no-pager | tail -n 20
        echo '```'
        
        echo "### 异常访问"
        echo '```'
        grep -i "error\|failed\|warning" /var/log/nginx/error.log | tail -n 20
        echo '```'
    } >> "$REPORT_FILE"
}

# 生成安全建议
generate_recommendations() {
    log "生成安全建议..."
    {
        echo "## 安全建议"
        echo "### 高优先级"
        # 检查并生成建议
        if grep -q "Failed password" /var/log/auth.log; then
            echo "- 建议：启用 fail2ban 加强 SSH 防护"
        fi
        if [ $(find / -type f -perm -2 2>/dev/null | wc -l) -gt 0 ]; then
            echo "- 建议：检查并修复世界可写文件权限"
        fi
        
        echo "### 中优先级"
        # 添加其他建议
        echo "- 定期更新系统包"
        echo "- 检查并更新 SSL 证书"
        echo "- 定期审查用户权限"
    } >> "$REPORT_FILE"
}

# 主函数
main() {
    log "开始安全审计..."
    
    # 创建报告头部
    {
        echo "# 安全审计报告"
        echo "## 生成时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo "## 系统信息"
        echo '```'
        uname -a
        echo '```'
        echo
    } > "$REPORT_FILE"
    
    # 执行各项审计
    audit_users
    audit_network
    audit_permissions
    audit_services
    audit_updates
    audit_logs
    generate_recommendations
    
    log "安全审计完成，报告已生成: $REPORT_FILE"
    
    # 发送通知
    ~/send_notification.sh "安全审计报告已生成" "normal"
}

# 执行审计
main
```
## 二十八、资源限制与控制
### 1. 资源限制配置脚本
```bash
# 创建资源限制配置脚本
nano ~/resource_control.sh
```
```bash
#!/bin/bash
# ~/resource_control.sh

# 配置
LOG_FILE="/var/log/resource_control.log"
LIMITS_CONF="/etc/security/limits.conf"
SYSTEMD_DIR="/etc/systemd/system"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 配置系统资源限制
configure_system_limits() {
    log "配置系统资源限制..."
    
    # 备份原始配置
    sudo cp "$LIMITS_CONF" "${LIMITS_CONF}.backup"
    
    # 添加资源限制配置
    sudo tee -a "$LIMITS_CONF" << EOF
# 用户资源限制
zhaoxiongzhou soft nofile 65535
zhaoxiongzhou hard nofile 65535
zhaoxiongzhou soft nproc 2048
zhaoxiongzhou hard nproc 4096

# 系统服务资源限制
www-data soft nofile 65535
www-data hard nofile 65535
www-data soft nproc 1024
www-data hard nproc 2048
EOF
}

# 配置 AI 服务资源限制
configure_ai_service() {
    log "配置 AI 服务资源限制..."
    
    # 创建 systemd 服务文件
    sudo tee "$SYSTEMD_DIR/llama-server.service" << EOF
[Unit]
Description=Llama AI Server
After=network.target

[Service]
User=zhaoxiongzhou
Group=zhaoxiongzhou
WorkingDirectory=/home/zhaoxiongzhou/projects/llama.cpp
ExecStart=/home/zhaoxiongzhou/projects/llama.cpp/start-llama.sh

# 资源限制
CPUQuota=80%
MemoryLimit=2G
TasksMax=128
LimitNOFILE=65535

# 重启策略
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

    # 重新加载 systemd 配置
    sudo systemctl daemon-reload
}

# 配置 Nginx 资源限制
configure_nginx() {
    log "配置 Nginx 资源限制..."
    
    # 修改 Nginx 配置
    sudo tee "/etc/nginx/conf.d/resource_limits.conf" << EOF
# 工作进程限制
worker_processes auto;
worker_rlimit_nofile 65535;

# 连接限制
events {
    worker_connections 1024;
    multi_accept on;
}

# 客户端限制
http {
    # 请求限制
    limit_req_zone \$binary_remote_addr zone=one:10m rate=10r/s;
    
    # 连接限制
    limit_conn_zone \$binary_remote_addr zone=addr:10m;
    
    server {
        # 应用限制
        location / {
            limit_req zone=one burst=5;
            limit_conn addr 10;
        }
    }
}
EOF
}

# 配置系统资源监控
configure_monitoring() {
    log "配置资源监控..."
    
    # 创建监控脚本
    cat > ~/monitor_resources.sh << EOF
#!/bin/bash

while true; do
    # CPU 使用率
    CPU_USAGE=\$(top -bn1 | grep "Cpu(s)" | awk '{print \$2}')
    
    # 内存使用率
    MEM_USAGE=\$(free | grep Mem | awk '{print \$3/\$2 * 100.0}')
    
    # 进程数
    PROCESS_COUNT=\$(ps aux | wc -l)
    
    # 检查限制
    if (( \$(echo "\$CPU_USAGE > 80" | bc -l) )); then
        ~/send_notification.sh "警告: CPU 使用率过高 (\${CPU_USAGE}%)" "high"
    fi
    
    if (( \$(echo "\$MEM_USAGE > 90" | bc -l) )); then
        ~/send_notification.sh "警告: 内存使用率过高 (\${MEM_USAGE}%)" "high"
    fi
    
    if [ "\$PROCESS_COUNT" -gt 200 ]; then
        ~/send_notification.sh "警告: 进程数过多 (\$PROCESS_COUNT)" "high"
    fi
    
    sleep 60
done
EOF

    chmod +x ~/monitor_resources.sh
}

# 应用配置
apply_configurations() {
    log "应用资源限制配置..."
    
    # 重启服务
    sudo systemctl restart nginx
    sudo systemctl restart llama-server
    
    # 启动监控
    ~/monitor_resources.sh &
    
    # 验证配置
    log "验证配置..."
    sudo nginx -t
    sudo systemctl status llama-server
    ulimit -a
}

# 主函数
main() {
    log "开始配置资源限制..."
    
    configure_system_limits
    configure_ai_service
    configure_nginx
    configure_monitoring
    apply_configurations
    
    log "资源限制配置完成"
}

# 执行配置
main
```
## 二十九、自动化测试系统
### 1. 集成测试脚本
```bash
# 创建集成测试脚本
nano ~/integration_test.sh
```
```bash
#!/bin/bash
# ~/integration_test.sh

# 配置
TEST_DIR="/home/zhaoxiongzhou/tests"
REPORT_DIR="/home/zhaoxiongzhou/test_reports"
LOG_FILE="/var/log/integration_test.log"

# 确保目录存在
mkdir -p "$TEST_DIR" "$REPORT_DIR"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 测试 Web 服务
test_web_service() {
    log "测试 Web 服务..."
    local result=0
    
    # 测试首页访问
    if curl -s -o /dev/null -w "%{http_code}" http://localhost/ | grep -q "200"; then
        log "首页访问测试通过"
    else
        log "错误: 首页访问测试失败"
        result=1
    fi
    
    # 测试静态资源
    if curl -s -o /dev/null -w "%{http_code}" http://localhost/css/main.css | grep -q "200"; then
        log "静态资源测试通过"
    else
        log "错误: 静态资源测试失败"
        result=1
    fi
    
    # 测试 404 页面
    if curl -s -o /dev/null -w "%{http_code}" http://localhost/nonexistent | grep -q "404"; then
        log "404 页面测试通过"
    else
        log "错误: 404 页面测试失败"
        result=1
    fi
    
    return $result
}

# 测试 AI 服务
test_ai_service() {
    log "测试 AI 服务..."
    local result=0
    
    # 测试服务可用性
    if curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health | grep -q "200"; then
        log "AI 服务健康检查通过"
    else
        log "错误: AI 服务健康检查失败"
        result=1
    fi
    
    # 测试模型响应
    local response=$(curl -s -X POST \
        -H "Content-Type: application/json" \
        -d '{"prompt": "Hello", "max_tokens": 10}' \
        http://localhost:8080/completion)
    
    if echo "$response" | grep -q "text"; then
        log "AI 服务响应测试通过"
    else
        log "错误: AI 服务响应测试失败"
        result=1
    fi
    
    return $result
}

# 测试系统服务
test_system_services() {
    log "测试系统服务..."
    local result=0
    
    # 测试 Nginx 状态
    if systemctl is-active --quiet nginx; then
        log "Nginx 服务测试通过"
    else
        log "错误: Nginx 服务测试失败"
        result=1
    fi
    
    # 测试系统资源
    local cpu_usage=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}')
    local mem_usage=$(free | grep Mem | awk '{print $3/$2 * 100.0}')
    
    if [ $(echo "$cpu_usage < 90" | bc -l) -eq 1 ]; then
        log "CPU 使用率正常"
    else
        log "警告: CPU 使用率过高"
        result=1
    fi
    
    if [ $(echo "$mem_usage < 90" | bc -l) -eq 1 ]; then
        log "内存使用率正常"
    else
        log "警告: 内存使用率过高"
        result=1
    fi
    
    return $result
}

# 生成测试报告
generate_report() {
    local web_result=$1
    local ai_result=$2
    local system_result=$3
    local report_file="$REPORT_DIR/test_report_$(date +%Y%m%d_%H%M%S).md"
    
    {
        echo "# 集成测试报告"
        echo "## 测试时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo
        echo "## 测试结果摘要"
        echo "- Web 服务: $([ $web_result -eq 0 ] && echo '通过 ✅' || echo '失败 ❌')"
        echo "- AI 服务: $([ $ai_result -eq 0 ] && echo '通过 ✅' || echo '失败 ❌')"
        echo "- 系统服务: $([ $system_result -eq 0 ] && echo '通过 ✅' || echo '失败 ❌')"
        echo
        echo "## 详细日志"
        echo '```'
        tail -n 50 "$LOG_FILE"
        echo '```'
    } > "$report_file"
    
    log "测试报告已生成: $report_file"
}

# 主函数
main() {
    log "开始集成测试..."
    
    local web_result=0
    local ai_result=0
    local system_result=0
    
    # 执行测试
    test_web_service
    web_result=$?
    
    test_ai_service
    ai_result=$?
    
    test_system_services
    system_result=$?
    
    # 生成报告
    generate_report $web_result $ai_result $system_result
    
    # 发送通知
    if [ $web_result -eq 0 ] && [ $ai_result -eq 0 ] && [ $system_result -eq 0 ]; then
        ~/send_notification.sh "集成测试全部通过" "normal"
    else
        ~/send_notification.sh "集成测试存在失败项，请查看报告" "high"
    fi
    
    # 返回总体结果
    return $(( web_result + ai_result + system_result ))
}

# 执行测试
main
```
## 三十、系统状态仪表板
### 1. 状态监控页面生成脚本
```bash
# 创建状态页面生成脚本
nano ~/generate_dashboard.sh
```
```bash
#!/bin/bash
# ~/generate_dashboard.sh

# 配置
DASHBOARD_DIR="/var/www/html/dashboard"
REFRESH_INTERVAL=60  # 页面刷新间隔（秒）
LOG_FILE="/var/log/dashboard.log"

# 确保目录存在
sudo mkdir -p "$DASHBOARD_DIR"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 收集系统状态数据
collect_system_data() {
    # CPU 信息
    CPU_USAGE=$(top -bn1 | grep "Cpu(s)" | awk '{print $2}')
    CPU_TEMP=$(vcgencmd measure_temp | sed 's/temp=//' | sed 's/'"'"'C//')
    
    # 内存信息
    MEM_TOTAL=$(free -m | awk '/Mem:/ {print $2}')
    MEM_USED=$(free -m | awk '/Mem:/ {print $3}')
    MEM_USAGE=$(awk "BEGIN {printf \"%.2f\", $MEM_USED/$MEM_TOTAL*100}")
    
    # 磁盘信息
    DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
    
    # 系统负载
    LOAD_AVG=$(uptime | awk -F'load average:' '{print $2}' | xargs)
    
    # 运行时间
    UPTIME=$(uptime -p)
}

# 收集服务状态
collect_service_data() {
    # Nginx 状态
    if systemctl is-active --quiet nginx; then
        NGINX_STATUS="运行中 ✅"
    else
        NGINX_STATUS="已停止 ❌"
    fi
    
    # AI 服务状态
    if pgrep -f llama-server > /dev/null; then
        AI_STATUS="运行中 ✅"
    else
        AI_STATUS="已停止 ❌"
    fi
    
    # 获取最近的日志
    RECENT_LOGS=$(tail -n 10 /var/log/syslog | sed 's/</\&lt;/g' | sed 's/>/\&gt;/g')
}

# 生成状态页面
generate_dashboard() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    cat > "$DASHBOARD_DIR/index.html" << EOF
<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>系统状态仪表板</title>
    <meta http-equiv="refresh" content="$REFRESH_INTERVAL">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .card {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        .metric {
            text-align: center;
            padding: 15px;
            border-radius: 4px;
            background: #f8f9fa;
        }
        .metric h3 {
            margin: 0;
            color: #666;
        }
        .metric .value {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }
        .status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .logs {
            background: #2b2b2b;
            color: #fff;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>系统状态仪表板</h1>
        <p>最后更新: $timestamp</p>
        
        <div class="card">
            <h2>系统资源</h2>
            <div class="grid">
                <div class="metric">
                    <h3>CPU 使用率</h3>
                    <div class="value">$CPU_USAGE%</div>
                </div>
                <div class="metric">
                    <h3>CPU 温度</h3>
                    <div class="value">$CPU_TEMP</div>
                </div>
                <div class="metric">
                    <h3>内存使用率</h3>
                    <div class="value">$MEM_USAGE%</div>
                </div>
                <div class="metric">
                    <h3>磁盘使用率</h3>
                    <div class="value">$DISK_USAGE%</div>
                </div>
            </div>
        </div>
        
        <div class="card">
            <h2>系统信息</h2>
            <div class="status">
                <span>系统负载:</span>
                <span>$LOAD_AVG</span>
            </div>
            <div class="status">
                <span>运行时间:</span>
                <span>$UPTIME</span>
            </div>
        </div>
        
        <div class="card">
            <h2>服务状态</h2>
            <div class="status">
                <span>Nginx 服务:</span>
                <span>$NGINX_STATUS</span>
            </div>
            <div class="status">
                <span>AI 服务:</span>
                <span>$AI_STATUS</span>
            </div>
        </div>
        
        <div class="card">
            <h2>最近日志</h2>
            <div class="logs">$RECENT_LOGS</div>
        </div>
    </div>
</body>
</html>
EOF

    # 设置权限
    sudo chown www-data:www-data "$DASHBOARD_DIR/index.html"
}

# 主函数
main() {
    log "开始生成状态仪表板..."
    
    # 收集数据
    collect_system_data
    collect_service_data
    
    # 生成页面
    generate_dashboard
    
    log "状态仪表板已更新"
}

# 执行生成
main
```
## 三十一、系统备份与恢复完整方案
### 1. 完整备份脚本
```bash
# 创建完整备份脚本
nano ~/full_backup.sh
```
```bash
#!/bin/bash
# ~/full_backup.sh

# 配置
BACKUP_ROOT="/mnt/backup_drive"
BACKUP_DIR="$BACKUP_ROOT/system_backups"
EXCLUDE_FILE="/home/zhaoxiongzhou/backup_exclude.txt"
LOG_FILE="/var/log/backup.log"
RETENTION_DAYS=30
COMPRESSION_LEVEL=6

# 确保备份目录存在
mkdir -p "$BACKUP_DIR"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 检查备份环境
check_environment() {
    log "检查备份环境..."
    
    # 检查备份目标目录
    if ! mountpoint -q "$BACKUP_ROOT"; then
        log "错误: 备份驱动器未挂载"
        return 1
    fi
    
    # 检查可用空间
    local available_space=$(df -BG "$BACKUP_ROOT" | awk 'NR==2 {print $4}' | sed 's/G//')
    if [ "$available_space" -lt 10 ]; then
        log "错误: 备份空间不足（小于 10GB）"
        return 1
    fi
    
    # 创建排除文件
    cat > "$EXCLUDE_FILE" << EOF
/proc/*
/sys/*
/tmp/*
/run/*
/mnt/*
/media/*
/lost+found
/var/cache/*
/var/tmp/*
/var/log/*
/home/*/Downloads/*
/home/*/.cache/*
EOF
    
    return 0
}

# 停止服务
stop_services() {
    log "停止服务..."
    
    # 停止 Nginx
    sudo systemctl stop nginx
    
    # 停止 AI 服务
    pkill llama-server
    
    # 等待服务完全停止
    sleep 5
}

# 启动服务
start_services() {
    log "启动服务..."
    
    # 启动 Nginx
    sudo systemctl start nginx
    
    # 启动 AI 服务
    ~/projects/llama.cpp/start-llama.sh
    
    # 验证服务状态
    sleep 10
    if ! systemctl is-active --quiet nginx; then
        log "警告: Nginx 服务未能正常启动"
    fi
    if ! pgrep -f llama-server > /dev/null; then
        log "警告: AI 服务未能正常启动"
    fi
}

# 创建完整备份
create_full_backup() {
    local backup_date=$(date +%Y%m%d_%H%M%S)
    local backup_file="$BACKUP_DIR/full_backup_${backup_date}.tar.gz"
    local manifest_file="$BACKUP_DIR/backup_manifest_${backup_date}.txt"
    
    log "开始创建完整备份..."
    
    # 创建文件清单
    log "生成文件清单..."
    find / -xdev -type f ! -path "$(cat $EXCLUDE_FILE | tr '\n' '|')" > "$manifest_file"
    
    # 创建备份
    log "创建系统备份..."
    sudo tar -czf "$backup_file" \
        --exclude-from="$EXCLUDE_FILE" \
        --one-file-system \
        --preserve-permissions \
        --numeric-owner \
        --checkpoint=1000 \
        --checkpoint-action=dot \
        -C / .
    
    # 验证备份
    if ! tar -tzf "$backup_file" >/dev/null 2>&1; then
        log "错误: 备份文件验证失败"
        return 1
    fi
    
    # 计算校验和
    log "计算校验和..."
    sha256sum "$backup_file" > "${backup_file}.sha256"
    
    # 创建备份信息文件
    cat > "${backup_file}.info" << EOF
备份时间: $(date)
系统版本: $(cat /etc/os-release | grep PRETTY_NAME)
内核版本: $(uname -r)
备份大小: $(du -h "$backup_file" | cut -f1)
文件数量: $(wc -l < "$manifest_file")
排除规则: $(cat "$EXCLUDE_FILE")
EOF
    
    return 0
}

# 清理旧备份
cleanup_old_backups() {
    log "清理旧备份..."
    
    find "$BACKUP_DIR" -type f -name "full_backup_*" -mtime +$RETENTION_DAYS -delete
    find "$BACKUP_DIR" -type f -name "backup_manifest_*" -mtime +$RETENTION_DAYS -delete
    find "$BACKUP_DIR" -type f -name "*.sha256" -mtime +$RETENTION_DAYS -delete
    find "$BACKUP_DIR" -type f -name "*.info" -mtime +$RETENTION_DAYS -delete
}

# 主函数
main() {
    log "开始完整备份流程..."
    
    # 检查环境
    if ! check_environment; then
        log "备份环境检查失败，终止备份"
        ~/send_notification.sh "系统备份失败：环境检查未通过" "high"
        return 1
    fi
    
    # 停止服务
    stop_services
    
    # 创建备份
    if create_full_backup; then
        log "备份创建成功"
        ~/send_notification.sh "系统完整备份已成功创建" "normal"
    else
        log "备份创建失败"
        ~/send_notification.sh "系统备份失败：备份创建过程出错" "high"
    fi
    
    # 启动服务
    start_services
    
    # 清理旧备份
    cleanup_old_backups
    
    log "备份流程完成"
}

# 执行备份
main
```
## 三十二、系统恢复脚本
### 1. 系统恢复脚本
```bash
# 创建系统恢复脚本
nano ~/system_restore.sh
```
```bash
#!/bin/bash
# ~/system_restore.sh

# 配置
BACKUP_ROOT="/mnt/backup_drive"
BACKUP_DIR="$BACKUP_ROOT/system_backups"
LOG_FILE="/var/log/restore.log"
TEMP_DIR="/tmp/restore_temp"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 验证备份文件
verify_backup() {
    local backup_file="$1"
    log "验证备份文件: $backup_file"
    
    # 检查文件是否存在
    if [ ! -f "$backup_file" ]; then
        log "错误: 备份文件不存在"
        return 1
    fi
    
    # 检查校验和
    local checksum_file="${backup_file}.sha256"
    if [ -f "$checksum_file" ]; then
        if ! sha256sum -c "$checksum_file"; then
            log "错误: 备份文件校验和验证失败"
            return 1
        fi
    else
        log "警告: 未找到校验和文件"
    fi
    
    # 测试归档完整性
    if ! tar -tzf "$backup_file" >/dev/null 2>&1; then
        log "错误: 备份文件损坏"
        return 1
    fi
    
    return 0
}

# 准备恢复环境
prepare_environment() {
    log "准备恢复环境..."
    
    # 创建临时目录
    mkdir -p "$TEMP_DIR"
    
    # 停止所有服务
    log "停止服务..."
    sudo systemctl stop nginx
    pkill llama-server
    
    # 等待服务停止
    sleep 5
    
    # 清理目标目录
    log "清理目标目录..."
    read -p "警告: 这将清除系统文件。确定要继续吗？(y/n) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log "用户取消操作"
        return 1
    fi
    
    return 0
}

# 执行恢复
perform_restore() {
    local backup_file="$1"
    log "开始恢复系统..."
    
    # 创建恢复前的快照
    log "创建当前系统快照..."
    local snapshot_date=$(date +%Y%m%d_%H%M%S)
    local snapshot_file="$BACKUP_DIR/pre_restore_snapshot_${snapshot_date}.tar.gz"
    
    sudo tar -czf "$snapshot_file" \
        --exclude-from="/home/zhaoxiongzhou/backup_exclude.txt" \
        --one-file-system \
        -C / .
    
    # 解压备份
    log "解压备份文件..."
    sudo tar -xzf "$backup_file" -C / \
        --numeric-owner \
        --preserve-permissions \
        --checkpoint=1000 \
        --checkpoint-action=dot
    
    # 修复权限
    log "修复文件权限..."
    sudo chown -R www-data:www-data /var/www/
    sudo chown -R zhaoxiongzhou:zhaoxiongzhou /home/zhaoxiongzhou/
    
    return 0
}

# 恢复服务配置
restore_configurations() {
    log "恢复服务配置..."
    
    # 重新加载系统配置
    sudo systemctl daemon-reload
    sudo sysctl --system
    
    # 重新配置网络
    sudo systemctl restart networking
    
    # 恢复防火墙规则
    sudo iptables-restore < /etc/iptables/rules.v4
    
    return 0
}

# 验证恢复
verify_restore() {
    log "验证系统恢复..."
    local status=0
    
    # 检查关键文件
    for file in "/etc/nginx/nginx.conf" "/etc/systemd/system/llama-server.service"; do
        if [ ! -f "$file" ]; then
            log "错误: 未找到关键文件 $file"
            status=1
        fi
    done
    
    # 启动服务
    sudo systemctl start nginx
    ~/projects/llama.cpp/start-llama.sh
    
    # 验证服务状态
    sleep 10
    if ! systemctl is-active --quiet nginx; then
        log "错误: Nginx 服务未能正常启动"
        status=1
    fi
    
    if ! pgrep -f llama-server > /dev/null; then
        log "错误: AI 服务未能正常启动"
        status=1
    fi
    
    return $status
}

# 清理恢复环境
cleanup() {
    log "清理恢复环境..."
    
    # 删除临时文件
    rm -rf "$TEMP_DIR"
    
    # 清理日志
    find /var/log -type f -name "*.gz" -delete
    
    return 0
}

# 主函数
main() {
    local backup_file
    
    # 列出可用备份
    echo "可用的备份文件:"
    ls -lh "$BACKUP_DIR"/full_backup_*.tar.gz
    
    # 选择备份文件
    read -p "请输入要恢复的备份文件完整路径: " backup_file
    
    # 验证备份
    if ! verify_backup "$backup_file"; then
        log "备份验证失败，终止恢复"
        return 1
    fi
    
    # 准备环境
    if ! prepare_environment; then
        log "环境准备失败，终止恢复"
        return 1
    fi
    
    # 执行恢复
    if perform_restore "$backup_file" && \
       restore_configurations && \
       verify_restore; then
        log "系统恢复成功完成"
        ~/send_notification.sh "系统恢复成功完成" "normal"
    else
        log "系统恢复失败"
        ~/send_notification.sh "系统恢复失败，需要手动检查" "high"
    fi
    
    # 清理环境
    cleanup
}

# 执行恢复
main
```
## 三十三、系统迁移工具
### 1. 系统迁移脚本
```bash
# 创建系统迁移脚本
nano ~/system_migration.sh
```
```bash
#!/bin/bash
# ~/system_migration.sh

# 配置
SOURCE_HOST="old-raspberry.local"
TARGET_HOST="new-raspberry.local"
MIGRATION_DIR="/mnt/migration"
LOG_FILE="/var/log/migration.log"
SSH_KEY="~/.ssh/migration_key"
RSYNC_OPTS="-avz --progress --delete"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 检查迁移环境
check_migration_env() {
    log "检查迁移环境..."
    
    # 检查 SSH 密钥
    if [ ! -f "$SSH_KEY" ]; then
        log "生成 SSH 密钥..."
        ssh-keygen -t ed25519 -f "$SSH_KEY" -N ""
        
        # 复制密钥到目标主机
        ssh-copy-id -i "$SSH_KEY" "zhaoxiongzhou@$TARGET_HOST"
    fi
    
    # 检查必要工具
    for tool in rsync ssh scp; do
        if ! command -v $tool &>/dev/null; then
            log "错误: 未找到必要工具 $tool"
            return 1
        fi
    done
    
    # 检查目标主机连接
    if ! ssh -i "$SSH_KEY" "zhaoxiongzhou@$TARGET_HOST" "echo 'Connection test'" &>/dev/null; then
        log "错误: 无法连接到目标主机"
        return 1
    fi
    
    return 0
}

# 迁移配置文件
migrate_configs() {
    log "迁移配置文件..."
    
    # 创建配置目录
    ssh -i "$SSH_KEY" "zhaoxiongzhou@$TARGET_HOST" "mkdir -p ~/configs_backup"
    
    # 迁移 Nginx 配置
    rsync $RSYNC_OPTS -e "ssh -i $SSH_KEY" \
        /etc/nginx/ \
        "zhaoxiongzhou@$TARGET_HOST:~/configs_backup/nginx/"
    
    # 迁移系统配置
    rsync $RSYNC_OPTS -e "ssh -i $SSH_KEY" \
        /etc/sysctl.d/ \
        "zhaoxiongzhou@$TARGET_HOST:~/configs_backup/sysctl/"
    
    # 迁移服务配置
    rsync $RSYNC_OPTS -e "ssh -i $SSH_KEY" \
        /etc/systemd/system/ \
        "zhaoxiongzhou@$TARGET_HOST:~/configs_backup/systemd/"
}

# 迁移数据
migrate_data() {
    log "迁移数据..."
    
    # 迁移博客数据
    rsync $RSYNC_OPTS -e "ssh -i $SSH_KEY" \
        ~/myblog/ \
        "zhaoxiongzhou@$TARGET_HOST:~/myblog/"
    
    # 迁移 AI 服务数据
    rsync $RSYNC_OPTS -e "ssh -i $SSH_KEY" \
        ~/projects/llama.cpp/ \
        "zhaoxiongzhou@$TARGET_HOST:~/projects/llama.cpp/"
    
    # 迁移用户脚本
    rsync $RSYNC_OPTS -e "ssh -i $SSH_KEY" \
        ~/*.sh \
        "zhaoxiongzhou@$TARGET_HOST:~/"
}

# 迁移数据库
migrate_database() {
    log "迁移数据库..."
    
    # 导出数据库
    local dump_file="/tmp/database_dump.sql"
    if [ -f "/var/lib/mysql" ]; then
        mysqldump --all-databases > "$dump_file"
        
        # 传输到目标主机
        scp -i "$SSH_KEY" "$dump_file" "zhaoxiongzhou@$TARGET_HOST:/tmp/"
        
        # 在目标主机导入数据库
        ssh -i "$SSH_KEY" "zhaoxiongzhou@$TARGET_HOST" \
            "mysql < /tmp/database_dump.sql"
    fi
}

# 配置目标系统
configure_target() {
    log "配置目标系统..."
    
    ssh -i "$SSH_KEY" "zhaoxiongzhou@$TARGET_HOST" "bash -s" << 'EOF'
        # 安装必要软件
        sudo apt update
        sudo apt install -y nginx mysql-server python3 pip
        
        # 恢复配置
        sudo cp -r ~/configs_backup/nginx/* /etc/nginx/
        sudo cp -r ~/configs_backup/sysctl/* /etc/sysctl.d/
        sudo cp -r ~/configs_backup/systemd/* /etc/systemd/system/
        
        # 设置权限
        sudo chown -R www-data:www-data /var/www/
        sudo chmod +x ~/*.sh
        
        # 重启服务
        sudo systemctl daemon-reload
        sudo systemctl restart nginx
EOF
}

# 验证迁移
verify_migration() {
    log "验证迁移..."
    local status=0
    
    # 检查服务状态
    ssh -i "$SSH_KEY" "zhaoxiongzhou@$TARGET_HOST" "bash -s" << 'EOF'
        # 检查 Nginx
        if ! systemctl is-active --quiet nginx; then
            echo "错误: Nginx 服务未运行"
            exit 1
        fi
        
        # 检查文件
        for dir in "~/myblog" "~/projects/llama.cpp"; do
            if [ ! -d "$dir" ]; then
                echo "错误: 目录 $dir 不存在"
                exit 1
            fi
        done
        
        # 检查配置
        if ! nginx -t &>/dev/null; then
            echo "错误: Nginx 配置无效"
            exit 1
        fi
EOF
    
    status=$?
    return $status
}

# 主函数
main() {
    log "开始系统迁移..."
    
    # 检查环境
    if ! check_migration_env; then
        log "迁移环境检查失败"
        return 1
    fi
    
    # 执行迁移
    migrate_configs
    migrate_data
    migrate_database
    configure_target
    
    # 验证迁移
    if verify_migration; then
        log "系统迁移成功完成"
        ~/send_notification.sh "系统迁移成功完成" "normal"
    else
        log "系统迁移失败"
        ~/send_notification.sh "系统迁移失败，需要手动检查" "high"
    fi
}

# 执行迁移
main
```
## 三十四、日志分析工具
### 1. 日志分析脚本
```bash
# 创建日志分析脚本
nano ~/log_analyzer.sh
```
```bash
#!/bin/bash
# ~/log_analyzer.sh

# 配置
LOG_DIRS=(
    "/var/log"
    "/var/log/nginx"
    "/home/zhaoxiongzhou/logs"
)
REPORT_DIR="/home/zhaoxiongzhou/log_reports"
LOG_FILE="/var/log/analyzer.log"
ALERT_THRESHOLD=100  # 错误日志阈值
RETENTION_DAYS=30    # 报告保留天数

# 确保目录存在
mkdir -p "$REPORT_DIR"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 分析系统日志
analyze_system_logs() {
    log "分析系统日志..."
    local report_file="$REPORT_DIR/system_log_report_$(date +%Y%m%d).md"
    
    {
        echo "# 系统日志分析报告"
        echo "## 生成时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo
        echo "## 系统错误统计"
        echo "### 严重错误"
        echo '```'
        grep -i "error\|critical\|emergency" /var/log/syslog | \
            tail -n 50 | sort | uniq -c | sort -nr
        echo '```'
        
        echo "### 认证失败"
        echo '```'
        grep "Failed password" /var/log/auth.log | \
            awk '{print $1,$2,$3,$11}' | sort | uniq -c | sort -nr | head -n 10
        echo '```'
        
        echo "### 系统重启记录"
        echo '```'
        last reboot | head -n 5
        echo '```'
    } > "$report_file"
}

# 分析 Nginx 访问日志
analyze_nginx_logs() {
    log "分析 Nginx 访问日志..."
    local report_file="$REPORT_DIR/nginx_log_report_$(date +%Y%m%d).md"
    
    {
        echo "# Nginx 访问日志分析报告"
        echo "## 生成时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo
        echo "## 访问统计"
        echo "### 请求量最大的 IP"
        echo '```'
        awk '{print $1}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -n 10
        echo '```'
        
        echo "### 访问量最大的页面"
        echo '```'
        awk '{print $7}' /var/log/nginx/access.log | sort | uniq -c | sort -nr | head -n 10
        echo '```'
        
        echo "### HTTP 状态码统计"
        echo '```'
        awk '{print $9}' /var/log/nginx/access.log | sort | uniq -c | sort -nr
        echo '```'
        
        echo "### 每小时请求量统计"
        echo '```'
        awk '{print $4}' /var/log/nginx/access.log | cut -c 14-15 | sort | uniq -c | \
            awk '{printf("%s:00 - %s 请求\n", $2, $1)}'
        echo '```'
    } > "$report_file"
}

# 分析 AI 服务日志
analyze_ai_logs() {
    log "分析 AI 服务日志..."
    local report_file="$REPORT_DIR/ai_log_report_$(date +%Y%m%d).md"
    local ai_log="/home/zhaoxiongzhou/logs/llama.log"
    
    if [ -f "$ai_log" ]; then
        {
            echo "# AI 服务日志分析报告"
            echo "## 生成时间: $(date '+%Y-%m-%d %H:%M:%S')"
            echo
            echo "## 服务统计"
            echo "### 错误统计"
            echo '```'
            grep -i "error" "$ai_log" | tail -n 20
            echo '```'
            
            echo "### 性能统计"
            echo "#### 响应时间分布"
            echo '```'
            grep "response_time" "$ai_log" | \
                awk '{sum+=$NF; count++} END {print "平均响应时间:", sum/count, "ms"}'
            echo '```'
            
            echo "#### 内存使用统计"
            echo '```'
            grep "memory_usage" "$ai_log" | tail -n 10
            echo '```'
        } > "$report_file"
    fi
}

# 生成安全报告
generate_security_report() {
    log "生成安全报告..."
    local report_file="$REPORT_DIR/security_report_$(date +%Y%m%d).md"
    
    {
        echo "# 安全分析报告"
        echo "## 生成时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo
        echo "## 安全事件统计"
        
        echo "### SSH 暴力破解尝试"
        echo '```'
        grep "Failed password" /var/log/auth.log | \
            awk '{print $11,$13}' | sort | uniq -c | sort -nr | head -n 10
        echo '```'
        
        echo "### 可疑 IP 访问"
        echo '```'
        grep -i "suspicious\|attack\|hack" /var/log/nginx/access.log | \
            awk '{print $1}' | sort | uniq -c | sort -nr
        echo '```'
        
        echo "### 文件权限变更"
        echo '```'
        find /etc -mtime -1 -type f -ls
        echo '```'
    } > "$report_file"
}

# 清理旧报告
cleanup_old_reports() {
    log "清理旧报告..."
    find "$REPORT_DIR" -type f -name "*.md" -mtime +$RETENTION_DAYS -delete
}

# 生成摘要报告
generate_summary() {
    log "生成摘要报告..."
    local summary_file="$REPORT_DIR/summary_$(date +%Y%m%d).md"
    
    {
        echo "# 日志分析摘要报告"
        echo "## 生成时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo
        echo "## 关键指标"
        
        # 错误统计
        local error_count=$(grep -i "error" /var/log/syslog | wc -l)
        local nginx_error_count=$(grep -i "error" /var/log/nginx/error.log | wc -l)
        
        echo "- 系统错误数: $error_count"
        echo "- Nginx 错误数: $nginx_error_count"
        
        # 安全事件
        local ssh_fails=$(grep "Failed password" /var/log/auth.log | wc -l)
        echo "- SSH 失败尝试: $ssh_fails"
        
        # 告警判断
        if [ $error_count -gt $ALERT_THRESHOLD ]; then
            ~/send_notification.sh "警告: 系统错误数超过阈值" "high"
        fi
    } > "$summary_file"
}

# 主函数
main() {
    log "开始日志分析..."
    
    # 执行分析
    analyze_system_logs
    analyze_nginx_logs
    analyze_ai_logs
    generate_security_report
    generate_summary
    
    # 清理旧报告
    cleanup_old_reports
    
    log "日志分析完成"
}

# 执行分析
main
```
## 三十五、系统优化工具
### 1. 系统优化脚本
```bash
# 创建系统优化脚本
nano ~/system_optimize.sh
```
```bash
#!/bin/bash
# ~/system_optimize.sh

# 配置
LOG_FILE="/var/log/optimize.log"
NGINX_CONF="/etc/nginx/nginx.conf"
SYSCTL_CONF="/etc/sysctl.d/99-custom.conf"
JOURNAL_CONF="/etc/systemd/journald.conf"

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 优化系统参数
optimize_system() {
    log "优化系统参数..."
    
    # 备份原始配置
    cp "$SYSCTL_CONF" "${SYSCTL_CONF}.backup"
    
    # 配置系统参数
    cat > "$SYSCTL_CONF" << EOF
# 网络优化
net.core.somaxconn = 2048
net.core.netdev_max_backlog = 4096
net.ipv4.tcp_max_syn_backlog = 4096
net.ipv4.tcp_fin_timeout = 30
net.ipv4.tcp_keepalive_time = 1200
net.ipv4.tcp_max_tw_buckets = 5000
net.ipv4.tcp_fastopen = 3
net.ipv4.tcp_rmem = 4096 87380 16777216
net.ipv4.tcp_wmem = 4096 65536 16777216

# 文件系统优化
fs.file-max = 100000
fs.inotify.max_user_watches = 524288

# 内存优化
vm.swappiness = 10
vm.dirty_ratio = 60
vm.dirty_background_ratio = 2
EOF

    # 应用系统参数
    sysctl -p "$SYSCTL_CONF"
}

# 优化 Nginx 配置
optimize_nginx() {
    log "优化 Nginx 配置..."
    
    # 备份原始配置
    cp "$NGINX_CONF" "${NGINX_CONF}.backup"
    
    # 配置 Nginx
    cat > "$NGINX_CONF" << EOF
user www-data;
worker_processes auto;
worker_rlimit_nofile 100000;

events {
    worker_connections 2048;
    multi_accept on;
    use epoll;
}

http {
    # 基础设置
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_tokens off;

    # MIME 类型
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    # 日志格式
    log_format main '\$remote_addr - \$remote_user [\$time_local] "\$request" '
                    '\$status \$body_bytes_sent "\$http_referer" '
                    '"\$http_user_agent" "\$http_x_forwarded_for"';

    # 缓冲区设置
    client_body_buffer_size 128k;
    client_max_body_size 10m;
    client_header_buffer_size 1k;
    large_client_header_buffers 4 4k;

    # Gzip 压缩
    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;

    # SSL 优化
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;

    # 包含其他配置
    include /etc/nginx/conf.d/*.conf;
    include /etc/nginx/sites-enabled/*;
}
EOF

    # 测试配置
    nginx -t && systemctl restart nginx
}

# 优化系统服务
optimize_services() {
    log "优化系统服务..."
    
    # 禁用不必要的服务
    local unnecessary_services=(
        "bluetooth"
        "cups"
        "avahi-daemon"
    )
    
    for service in "${unnecessary_services[@]}"; do
        if systemctl is-active --quiet "$service"; then
            systemctl stop "$service"
            systemctl disable "$service"
            log "已禁用服务: $service"
        fi
    done
    
    # 优化日志服务
    cat > "$JOURNAL_CONF" << EOF
[Journal]
SystemMaxUse=100M
SystemMaxFileSize=10M
RuntimeMaxUse=50M
RuntimeMaxFileSize=5M
EOF

    # 重启日志服务
    systemctl restart systemd-journald
}

# 优化文件系统
optimize_filesystem() {
    log "优化文件系统..."
    
    # 清理临时文件
    find /tmp -type f -atime +10 -delete
    find /var/tmp -type f -atime +10 -delete
    
    # 清理日志
    find /var/log -type f -name "*.gz" -delete
    find /var/log -type f -name "*.old" -delete
    
    # 优化日志轮转
    cat > /etc/logrotate.d/custom << EOF
/var/log/custom/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 640 root adm
}
EOF
}

# 优化内存使用
optimize_memory() {
    log "优化内存使用..."
    
    # 清理缓存
    sync; echo 3 > /proc/sys/vm/drop_caches
    
    # 配置 swap 使用
    if [ -f /swapfile ]; then
        swapoff /swapfile
        dd if=/dev/zero of=/swapfile bs=1M count=2048
        chmod 600 /swapfile
        mkswap /swapfile
        swapon /swapfile
    fi
}

# 验证优化
verify_optimization() {
    log "验证系统优化..."
    local status=0
    
    # 检查系统负载
    local load=$(uptime | awk -F'load average:' '{print $2}' | cut -d, -f1)
    if [ $(echo "$load > 2" | bc -l) -eq 1 ]; then
        log "警告: 系统负载较高 ($load)"
        status=1
    fi
    
    # 检查内存使用
    local mem_usage=$(free | grep Mem | awk '{print $3/$2 * 100.0}')
    if [ $(echo "$mem_usage > 90" | bc -l) -eq 1 ]; then
        log "警告: 内存使用率过高 ($mem_usage%)"
        status=1
    fi
    
    # 检查服务状态
    if ! systemctl is-active --quiet nginx; then
        log "错误: Nginx 服务未正常运行"
        status=1
    fi
    
    return $status
}

# 主函数
main() {
    log "开始系统优化..."
    
    optimize_system
    optimize_nginx
    optimize_services
    optimize_filesystem
    optimize_memory
    
    if verify_optimization; then
        log "系统优化成功完成"
        ~/send_notification.sh "系统优化已完成" "normal"
    else
        log "系统优化完成，但存在警告"
        ~/send_notification.sh "系统优化完成，但需要检查" "high"
    fi
}

# 执行优化
main
```
## 三十六、部署后检查清单
### 1. 部署检查脚本
```bash
# 创建部署检查脚本
nano ~/deployment_checklist.sh
```
```bash
#!/bin/bash
# ~/deployment_checklist.sh

# 配置
LOG_FILE="/var/log/deployment_check.log"
REPORT_FILE="/home/zhaoxiongzhou/deployment_report.md"
CHECK_INTERVAL=300  # 检查间隔（秒）

# 日志函数
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" | tee -a "$LOG_FILE"
}

# 检查系统基础配置
check_system_basics() {
    log "检查系统基础配置..."
    local status=0
    
    {
        echo "## 系统基础检查"
        echo "### 系统信息"
        echo "- 主机名: $(hostname)"
        echo "- 系统版本: $(cat /etc/os-release | grep PRETTY_NAME)"
        echo "- 内核版本: $(uname -r)"
        echo "- 运行时间: $(uptime -p)"
        echo
        echo "### 资源使用"
        echo "- CPU 使用率: $(top -bn1 | grep "Cpu(s)" | awk '{print $2}')%"
        echo "- 内存使用率: $(free | grep Mem | awk '{print $3/$2 * 100.0}')%"
        echo "- 磁盘使用率: $(df -h / | awk 'NR==2 {print $5}')"
        echo
    } > "$REPORT_FILE"
    
    return $status
}

# 检查网络配置
check_network() {
    log "检查网络配置..."
    local status=0
    
    {
        echo "### 网络配置"
        echo "#### IP 配置"
        echo '```'
        ip addr show
        echo '```'
        
        echo "#### 路由表"
        echo '```'
        ip route
        echo '```'
        
        echo "#### 开放端口"
        echo '```'
        netstat -tuln
        echo '```'
        
        echo "#### DNS 配置"
        echo '```'
        cat /etc/resolv.conf
        echo '```'
    } >> "$REPORT_FILE"
    
    return $status
}

# 检查服务配置
check_services() {
    log "检查服务配置..."
    local status=0
    
    {
        echo "### 服务状态"
        echo "#### Nginx 配置"
        echo '```'
        nginx -T
        echo '```'
        
        echo "#### 服务运行状态"
        echo '```'
        systemctl status nginx
        systemctl status mysql
        ps aux | grep llama-server
        echo '```'
        
        echo "#### 服务日志检查"
        echo '```'
        tail -n 20 /var/log/nginx/error.log
        echo '```'
    } >> "$REPORT_FILE"
    
    return $status
}

# 检查安全配置
check_security() {
    log "检查安全配置..."
    local status=0
    
    {
        echo "### 安全检查"
        echo "#### 防火墙规则"
        echo '```'
        sudo iptables -L
        echo '```'
        
        echo "#### SSH 配置"
        echo '```'
        grep -v '^#' /etc/ssh/sshd_config
        echo '```'
        
        echo "#### 用户权限"
        echo '```'
        ls -la /home/zhaoxiongzhou/
        ls -la /var/www/
        echo '```'
        
        echo "#### SSL 证书"
        echo '```'
        openssl x509 -in /etc/nginx/ssl/server.crt -text -noout
        echo '```'
    } >> "$REPORT_FILE"
    
    return $status
}

# 检查备份配置
check_backups() {
    log "检查备份配置..."
    local status=0
    
    {
        echo "### 备份检查"
        echo "#### 备份配置"
        echo '```'
        ls -lh /mnt/backup_drive/system_backups/
        echo '```'
        
        echo "#### 最近备份状态"
        echo '```'
        tail -n 20 /var/log/backup.log
        echo '```'
    } >> "$REPORT_FILE"
    
    return $status
}

# 检查监控配置
check_monitoring() {
    log "检查监控配置..."
    local status=0
    
    {
        echo "### 监控检查"
        echo "#### 监控脚本状态"
        echo '```'
        ps aux | grep monitor
        echo '```'
        
        echo "#### 告警配置"
        echo '```'
        cat ~/send_notification.sh
        echo '```'
    } >> "$REPORT_FILE"
    
    return $status
}

# 生成总结报告
generate_summary() {
    log "生成总结报告..."
    
    {
        echo "## 部署检查总结"
        echo "### 检查时间: $(date '+%Y-%m-%d %H:%M:%S')"
        echo
        echo "### 主要发现"
        echo "1. 系统状态: $([ $system_status -eq 0 ] && echo '正常 ✅' || echo '异常 ❌')"
        echo "2. 网络配置: $([ $network_status -eq 0 ] && echo '正常 ✅' || echo '异常 ❌')"
        echo "3. 服务状态: $([ $services_status -eq 0 ] && echo '正常 ✅' || echo '异常 ❌')"
        echo "4. 安全配置: $([ $security_status -eq 0 ] && echo '正常 ✅' || echo '异常 ❌')"
        echo "5. 备份状态: $([ $backup_status -eq 0 ] && echo '正常 ✅' || echo '异常 ❌')"
        echo "6. 监控状态: $([ $monitoring_status -eq 0 ] && echo '正常 ✅' || echo '异常 ❌')"
        echo
        echo "### 建议操作"
        [ $system_status -ne 0 ] && echo "- 检查系统资源使用情况"
        [ $network_status -ne 0 ] && echo "- 验证网络配置"
        [ $services_status -ne 0 ] && echo "- 检查服务运行状态"
        [ $security_status -ne 0 ] && echo "- 审查安全配置"
        [ $backup_status -ne 0 ] && echo "- 确认备份是否正常"
        [ $monitoring_status -ne 0 ] && echo "- 检查监控系统"
    } >> "$REPORT_FILE"
}

# 主函数
main() {
    log "开始部署后检查..."
    
    # 执行检查
    check_system_basics
    system_status=$?
    
    check_network
    network_status=$?
    
    check_services
    services_status=$?
    
    check_security
    security_status=$?
    
    check_backups
    backup_status=$?
    
    check_monitoring
    monitoring_status=$?
    
    # 生成总结
    generate_summary
    
    # 发送通知
    if [ $system_status -eq 0 ] && [ $network_status -eq 0 ] && \
       [ $services_status -eq 0 ] && [ $security_status -eq 0 ] && \
       [ $backup_status -eq 0 ] && [ $monitoring_status -eq 0 ]; then
        ~/send_notification.sh "部署检查完成：所有项目正常" "normal"
    else
        ~/send_notification.sh "部署检查完成：存在需要关注的项目" "high"
    fi
    
    log "部署检查完成，报告已生成: $REPORT_FILE"
}

# 执行检查
main
```
《树莓派服务部署与维护完整指南》总共包含了 36 个部分，涵盖了从系统部署到维护的各个方面。每个脚本都经过精心设计，可以独立运行，也可以互相配合使用。
